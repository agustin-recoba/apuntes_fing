{"path":"Archivados/Programación Funcional/media/prueba.pdf","text":"Programaci´on Funcional Prueba Escrita - 2022 Nombre: CI: 1. Dada la siguiente deﬁnici´on: foo a b = head [fst (a + b, ⊥), fst (⊥, a < b)] El tipo m´as general es: (a) foo :: (Num a, Ord a) ⇒ a → a → (a, Bool ) (b) foo :: (Num a, Ord a) ⇒ a → a → a (c) foo :: (Num a, Ord a) ⇒ a → a → b (d) No tiene Respuesta: b) 2. Dada la siguiente deﬁnici´on: dup x = (x , x ) ¿Cu´al de las siguientes opciones NO es correcta?: (a) dup (4, 4) ≡ dup $ dup 4 (b) fst (dup dup) $ fst (fst, dup) est´a mal tipada (c) El tipo m´as general de dup ◦ dup es a → ((a, a), (a, a)) (d) El tipo m´as general de dup dup es (a → (a, a), a → (a, a)) Respuesta: b) 3. Dada la siguiente deﬁnici´on: mult4 = map f (g lst) ¿Cu´al de las siguientes implementaciones de f , g y lst NO hacen que mult4 devuelva la lista inﬁnita de los m´ultiplos de cuatro a partir del cero? Recuerde que: iterate f x = x : iterate f (f x ) (a) f = (2∗), g = map (λx → x + x ), lst = iterate (+1) 0 (b) f = id , g = map (‘div ‘ 2), lst = iterate (+8) 0 (c) f = id , g = foldl (λacc x → acc ++ [x ]) [ ], lst = iterate (+4) 0 (d) f = (+4), g = ﬁlter even, lst = iterate (+4) (−4) Respuesta: c) 1 4. Dada la siguiente deﬁnici´on: data Either a b = Left a | Right b data P = P I | Cero data I = I P foo (Left a) = Cero foo (Right (I a)) = foo (Left a) Indique la opci´on correcta: (a) El tipo m´as general de foo es Either P a → P (b) El tipo m´as general de foo es Either P I → P (c) El tipo m´as general de foo es Either a I → P (d) El c´odigo no compila Respuesta: b) 5. Dadas las siguientes deﬁniciones: data B a b = N [B a b ] | C [a ] [b ] bah f (N bs) = concat $ map (bah f ) bs bah f (C as bs) = zipWith f as bs puaj = N [C (repeat 0) [1, 2], N [C (repeat 0) [1, 2]]] ¿Cu´al de las siguientes aﬁrmaciones es correcta? (a) El c´odigo no compila (b) El resultado de evaluar bah (∗) puaj es [0, 0, 0, 0] (c) El resultado de evaluar bah (∗) puaj es [0, 0] (d) La evaluaci´on de bah (∗) puaj no termina Respuesta: b) 6. La funci´on lookup :: Eq k ⇒ k → [(k , a)] → Maybe a realiza una b´usqueda lineal en una lista de asociaciones de acuerdo a los siguientes ejemplos: lookup 4 [(3, ’a’), (4, ’h’), (1, ’p’), (4, ’m’)] retorna (Just ’h’) lookup 4 [(3, ’a’), (6, ’h’), (1, ’p’), (2, ’m’)] retorna Nothing Se puede implementar como un foldl de la siguiente forma: lookup k = foldl (pacc k ) Nothing Indique la opci´on que permite una implementaci´on correcta de lookup. (a) pacc k acc (c, v ) = acc >> if k == c then Just v else Nothing (b) pacc k acc (c, v ) = if k == c then Just v else acc (c) pacc k Nothing (c, v ) = if k == c then Just v else Nothing pacc k (Just u) (c, v ) = Just u (d) pacc k acc (k , v ) = Just v pacc k acc (c, v ) = acc Respuesta: c) 2 7. Dada la siguiente deﬁnici´on: cs = [1, 1] : map (λ(x : y : xs) → x + y : x : y : xs) cs Para cada una de las siguientes expresiones indique el resultado de su evaluaci´on o si la misma diverge (si pone diverge en todas las opciones anula la pregunta). (a) head (foldl ((:) ◦ head ) [ ] (tail cs)) diverge (b) head (foldr ((:) ◦ head ) [ ] (tail cs)) 2 (c) take 2 $ ﬁlter ((>4) ◦ head ) cs [[5,3,2,1,1],[8,5,3,2,1,1]] (d) take 2 $ ﬁlter ((<2) ◦ length) cs diverge (e) take 4 $ map head cs [1,2,3,5] (f) map reverse $ take 4 cs [[1,1],[1,1,2],[1,1,2,3],[1,1,2,3,5]] (g) length ◦ head ◦ tail ◦ tail $ cs 4 (h) length ◦ tail ◦ tail $ cs diverge 8. Consideramos la siguiente deﬁnici´on de expresiones con valores de un tipo arbitrario. data Exp val = O | V val | S (Exp val ) (Exp val ) foldE :: (a → a → a) → (b → a) → a → Exp b → a foldE s v o O = o foldE s v o (V c) = v c foldE s v o (S e1 e2 ) = s (foldE s v o e1 ) (foldE s v o e2 ) ¿Cu´al de las siguientes aﬁrmaciones NO es correcta? (a) Dada una expresi´on con tipo Exp Int, la aplicaci´on foldE min id 0 retorna el m´ınimo de sus valores (b) Dada una expresi´on con tipo Exp a, la aplicaci´on foldE (++) (λx → [x ]) [ ] devuelve una lista con sus valores, de izquierda a derecha (c) Dada una expresi´on con tipo Exp Int, la aplicaci´on foldE (+) id 0 suma sus valores (d) Dada una expresi´on con tipo Exp a, la aplicaci´on foldE (+) (const 0) 1 cuenta la cantidad de Os Respuesta: a) 3 9. Implemente usando recursi´on expl´ıcita la funci´on: ﬁlterDup :: Eq a ⇒ [a ] → ([a ], Int) que dada una lista de elementos comparables se devuelve esa lista sin elementos repetidos y la cantidad de elementos elimi- nados. Si un elemento aparece m´ultiples veces se queda con la ´ultima aparici´on. Por ejemplo, ﬁlterDup [1, 2, 3, 4, 5, 2, 3, 4, 3] devuelve el par ([1, 5, 2, 4, 3], 4). Puede resultarle de utilidad la funci´on elem :: Eq a ⇒ a → [a ] → Bool ﬁlterDup [ ] = ([ ], 0) ﬁlterDup (x : xs) | elem x rs = (rs, n + 1) | otherwise = (x : rs, n) where (rs, n) = ﬁlterDup xs Implemente la misma funci´on, pero como un foldr . ﬁlterDup = foldr (λx (rs, n) → if elem x rs then (rs, n + 1) else (x : rs, n)) ([ ], 0) 10. Implemente, sin usar recursi´on, el operador ($>) :: [a → b ] → a → [b ] que aplica un argumento dado a cada funci´on de una lista. Por ejemplo, [(+5), (∗2), (∗0)]$>8 devuelve la lista [13, 16, 0]. fs $> x = map ($ x ) fs 4","libVersion":"0.3.1","langs":""}