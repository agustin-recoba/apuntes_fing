{"path":"Bases de datos/pdfs/resumen_2009.pdf","text":"Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 1 Fundamentos de Base de Datos Contenido Dise√±o Conceptual ‚Äì MODELADO ER ......................................................................................... 4 Modelado Conceptual ........................................................................................................... 4 Modelo Entidad-Relaci√≥n (MER) ............................................................................................ 5 Algoritmo de Modelizaci√≥n................................................................................................ 6 Restricciones ..................................................................................................................... 6 Otros elementos del MER .................................................................................................. 6 Calidad de Esquemas y Correctitud.................................................................................... 7 Modelo y √Ålgebra Relacional ..................................................................................................... 9 Modelo Relacional ................................................................................................................ 9 Conceptos generales ......................................................................................................... 9 Caracter√≠sticas de Relaciones............................................................................................. 9 Restricciones de Integridad ............................................................................................... 9 Operaciones .................................................................................................................... 10 Algebra Relacional .............................................................................................................. 11 Selecci√≥n - ùùàùúΩ(ùíì) ............................................................................................................ 11 Proyecci√≥n - ùùÖùú∂(ùíì) ......................................................................................................... 11 Uni√≥n ‚Äì R U S .................................................................................................................. 11 Diferencia ‚Äì R ‚Äì S ............................................................................................................ 11 Producto Cartesiano ‚Äì R x S ............................................................................................. 11 JOIN ‚Äì R |x|∆ü S ................................................................................................................ 12 DIVISION - R % S ............................................................................................................. 12 C√°lculo Relacional ................................................................................................................... 13 C√°lculo de Tuplas ................................................................................................................ 13 F√≥rmulas Seguras ............................................................................................................ 14 Calculo de Dominios ............................................................................................................ 14 SQL ......................................................................................................................................... 15 La sentencia SELECT ............................................................................................................ 15 Order By .......................................................................................................................... 15 Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 2 Distinct ............................................................................................................................ 15 Joins ................................................................................................................................ 15 Renombrar Atributos ...................................................................................................... 15 Union .............................................................................................................................. 16 Diferencia........................................................................................................................ 16 Funciones ........................................................................................................................ 16 Consultas Anidadas ......................................................................................................... 16 Group By ......................................................................................................................... 16 Having ............................................................................................................................. 16 Dise√±o de Base de Datos Relacional ........................................................................................ 17 Pautas Informales ............................................................................................................... 17 Sem√°ntica de los Atributos .............................................................................................. 17 Reducci√≥n de Valores Redundantes ................................................................................. 17 Reducci√≥n de Valores Nulos ............................................................................................ 17 Inexistencia de Tuplas Err√≥neas ....................................................................................... 17 Dependencias Funcionales .................................................................................................. 17 Clausura de F ‚Äì F+ ........................................................................................................... 18 Algoritmo de Cubrimiento Minimal ................................................................................. 19 Formas Normales ................................................................................................................ 20 Claves y Superclaves ........................................................................................................ 20 Atributos y Dependencias................................................................................................ 20 Primera Forma Normal (1NF) .......................................................................................... 20 Segunda Forma Normal (2NF) ......................................................................................... 20 Tercera Forma Normal (3NF) ........................................................................................... 21 Forma Normal Boyce-CODD (BCNF) ................................................................................. 21 Algoritmos de Dise√±o .......................................................................................................... 22 Descomposici√≥n de Relaciones y Joins Sin Perdida .......................................................... 22 Descomposici√≥n en 3NF con pres de dependencias ......................................................... 22 Test Join Sin Perdidas (Test JSP)....................................................................................... 23 Descomposici√≥n en BCNF con JSP .................................................................................... 23 Descomposici√≥n en 3NF con JSP y Pres. Dependencias .................................................... 23 Dependencias Multivaluadas y Cuarta Forma Normal.......................................................... 24 Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 3 Cuarta Forma Normal ...................................................................................................... 24 Estrategias de un DBMS .......................................................................................................... 25 Procesamiento y Optimizaci√≥n de Consultas ....................................................................... 25 Organizaci√≥n y Acceso a los datos ................................................................................... 25 Procesamiento de consultas ............................................................................................ 26 Optimizaci√≥n de Consultas .............................................................................................. 26 Control de Concurrencia ..................................................................................................... 29 Transacciones.................................................................................................................. 29 Concurrencia ................................................................................................................... 29 Manejador de Transacciones ............................................................................................... 30 Serializaci√≥n .................................................................................................................... 30 Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 4 Dise√±o Conceptual ‚Äì MODELADO ER Modelado Conceptual Es la primera etapa en el dise√±o de una BD. Consiste en estudiar el problema real, especificar usando lenguaje de muy alto nivel y validar resultado. Se concentra en definir el dominio del problema (estructura y restricciones de integridad). En los modelos de datos conceptuales encontramos: ÔÇ∑ Conjuntos Los elementos de inter√©s aparecen agrupados o clasificados en conjuntos de acuerdo a sus caracter√≠sticas ÔÇ∑ Relaciones entre conjuntos Conjuntos de parejas, ternas, cuaternas, de elementos de los conjuntos anteriores. ÔÇ∑ Restricciones de integridad Condiciones que indican cuando un elemento o una pareja puede o no puede pertenecer a un conjunto o relaci√≥n. Se distinguen los siguientes t√©rminos en el modelado conceptual ÔÇ∑ Atributos Caracter√≠stica de inter√©s de un determinado elemento de la realidad ÔÇ∑ Cardinalidad Cuantos elementos de un conjunto pueden estar relacionados con elemento de origen. La cardinalidad puede ser (N:1 o N:N) ÔÇ∑ Totalidad Dada una relaci√≥n entre dos conjuntos A y B se dice que es Total con respecto a A si todos los elementos de A deben aparecer en alguna pareja de la relaci√≥n. En la modelizaci√≥n conceptual, se construyen esquemas conceptuales de una realidad. Existen dos principios que NO podemos olvidar: ÔÇ∑ Principio del 100% El esquema conceptual asociado a un problema debe representar todos sus aspectos ÔÇ∑ Principio de Conceptualizaci√≥n El esquema conceptual no debe incluir ning√∫n elemento asociado a la implementaci√≥n del esquema, as√≠ como ning√∫n elemento orientado a la performance futura de la BD. Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 5 Modelo Entidad-Relaci√≥n (MER) Los conceptos b√°sicos del modelo entidad relaci√≥n son la existencia de entidades (elementos de la realidad) y relaciones (asociaciones entre elementos). El MER tiene dos elementos b√°sicos : ÔÇ∑ Diagrama Entidad-Relaci√≥n ÔÇ∑ Restricciones no estructurales Los elementos que definen y se utilizan para la construcci√≥n del diagrama son: ÔÇ∑ Entidades ÔÇ∑ Relaciones ÔÇ∑ Atributos ÔÇ∑ Generalizaciones - Especializacion ÔÇ∑ Agregaciones ÔÇ∑ Entidades D√©biles Nombre-Entidad Entidad-1 Entidad-2 Nombre-Entidad Atributo X Atributo Y Entidad Madre Entidad 1 Entidad 2 Entidad-1 Entidad-2 Entidad-D√©bil Entidad-Fuerte Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 6 Algoritmo de Modelizaci√≥n 1. Identificar elementos del problema 2. Identificar relaciones entre objetos 3. Representar propiedades de inter√©s 4. Determinar restricciones Una ENTIDAD es un elemento distinguible de nuestra realidad. Las entidades se agrupan en Conjuntos de Entidades o Tipos de Entidades. Un ATRIBUTO es una funci√≥n tal que dado un elemento de un determinado conjunto de entidades, devuelve un valor de un determinado conjunto de valores. Los atributos pueden ser comunes, estructurados (compuestos) o multivalorados. Restricciones Se dice que un atributo es DETERMINANTE cuando no pueden existir dos entidades en el conjunto que tengan el mismo valor en ese atributo. Permite IDENTIFICAR a las entidades. La CARDINALIDAD en las relaciones nos indica cuantos elementos de un conjunto pueden estar relacionados con un elemento del otro conjunto y viceversa. Se indica poniendo las cantidades en la relaci√≥n. La TOTALIDAD nos indica que todo elemento de un conjunto A debe aparecer en alguna pareja de la relaci√≥n A-B. Se representa de la siguiente forma: Tambi√©n existen relaciones sobre las relaciones NO ESTRUCTURALES. Estas se definen en lenguaje natural o con algebra relaci√≥n de manera de poder a√±adir informaci√≥n al diagrama. Otros elementos del MER Se permite agregar Atributos en Relaciones, cuando el atributo no es espec√≠fico de las entidades que forman la relaci√≥n sino que surge de la propia relaci√≥n. Se permiten usar Autorelaciones, pero es necesario utilizar roles y restricciones nos estructurales para evitar cicrularidad. Se pueden crear relaciones multiples que contemplan m√°s de dos entidades. Entidad-A Entidad-B Entidad-1 Entidad-2 Entidad-3 Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 7 La relaci√≥n triple anterior no permite que existan parejas (Entidad-1, Entidad-2) si no existe la relaci√≥n con Entidad-3. Si quisi√©ramos permitir que puedan existir esas parejas y a su vez si existe la pareja relacionarla con la Entidad-3, deber√≠amos aplicar el concepto de agregaci√≥n. Calidad de Esquemas y Correctitud Para asegurar la calidad de los esquemas conceptuales se define un conjunto de propiedades que se deben chequear durante y al final del desarrollo. Maximizar Completitud y Correctitud Balancear Minimalidad, Expresividad, Explicitud Un esquema es COMPLETO cuando representa todas las caracter√≠sticas relevantes del problema. Para ello, debemos chequear: ÔÇ∑ Todos los conceptos del problema est√©n representados en alguna parte ÔÇ∑ Todos los requerimientos sean realizables con el esquema ÔÇ∑ Leer el resultado y compararlo con la descripci√≥n original. Existen dos tipos de CORRECTITUD. La Sint√°ctica y la Sem√°ntica. Un esquema es correcto sint√°cticamente cuando las distintas partes de este est√°n construidas correctamente con respecto al lenguaje utilizado. Para ello debemos chequear: ÔÇ∑ Existencia de cardinalidades en cada relaci√≥n ÔÇ∑ Existencia de atributos determinantes en cada entidad, si no existen verificar que sea entidad d√©bil. ÔÇ∑ Existencia de una y solo una relaci√≥n y todas las entidades que intervienen en la misma dentro de cada agregaci√≥n. Entidad-1 Entidad-2 Entidad-3 Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 8 Un esquema es correcto sem√°nticamente si cada elemento del problema se representa utilizando estructuras adecuadas. Para comprobarlo, chequear y responder para cada concepto del problema: ÔÇ∑ Atributo, entidad o relaci√≥n? ÔÇ∑ Una sola categor√≠a de entidades o m√°s de una? ÔÇ∑ Una relaci√≥n binaria o m√∫ltiple? ÔÇ∑ Cu√°l es el mecanismo de determinaci√≥n de un conjunto? ÔÇ∑ Las cardinalidades y totalidades tienen sentido? Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 9 Modelo y √Ålgebra Relacional Modelo Relacional Las estructuras consisten en TABLAS cuyas columnas corresponden a ATRIBUTOS de tipo at√≥mico y las filas corresponden a registros de datos. Las operaciones est√°n fundamentalmente orientadas a manejo de TABLAS, como conjunto de registros. Es un modelo de datos extremadamente simple y claro, que tambi√©n ha resultado potente para la mayor parte de las aplicaciones de las BDs. Conceptos generales ÔÇ∑ Dominio D Conjunto de valores at√≥micos ÔÇ∑ Esquema Relaci√≥n R (A1‚Ä¶An) R es el nombre de la relaci√≥n, A1‚Ä¶An son los atributos con dominio D1‚Ä¶Dn. ÔÇ∑ Relaci√≥n r (R) Es una instancia de un esquema R. Consiste en un conjunto de tuplas ÔÇ∑ Tupla Elemento de un producto cartesiano de N dominios. Caracter√≠sticas de Relaciones Una relaci√≥n es un conjunto de tuplas que NO ESTA ORDENADO y donde NO EXISTEN REPETIDOS. Los valores de los atributos en las tuplas, son valores at√≥micos (primera forma normal). Restricciones de Integridad ÔÇ∑ Restricciones de Dominio (de tipo) ÔÇ∑ Superclave y Clave Dado R(A1‚Ä¶An) se dice que X C {A1‚Ä¶An} es superclave en un esquema R, si no puede existir ninguna r(R) tal que tenga dos tuplas con valores iguales de X. Una clave es una superclave minimal (no contiene propiamente una superclave). ÔÇ∑ Integridad Referencial Dado R, un conjunto de atributos X es una FK (Foreign Key) de R si: o Los atributos de X coinciden en dominio con los de una clave Y de S. o Los valores de X en tuplas de r(R) corresponden a valores de Y en s(S). (Existe una RI Referencial entre R y S) Las restricciones de integridad surgen de la observaci√≥n de la realidad, se definen a nivel de esquema relaci√≥n, y son violadas por instancias. Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 10 Operaciones ÔÇ∑ INSERT (a,b,c) into R Incluye la tupla (a,b,c) en la relaci√≥n r. Debe cumplir las RI. ÔÇ∑ DELETE from R where A = ‚Äòa‚Äô Borra de las tuplas de r cuyo valor para A es ‚Äòa‚Äô. Puede generar violaciones RI. ÔÇ∑ UPDATE R set A=‚Äôa1‚Äô where B = ‚Äòb1‚Äô Modifica las tuplas cuyo valor de r es B = b1, colocando a1 como valor de A. Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 11 Algebra Relacional A partir de un conjunto de operadores para consultar BD relacionales, define un conjunto de operaciones est√°ndar en BD. Los operadores reciben relaciones y devuelve relaciones. Las operaciones comunes para tuplas son la uni√≥n, diferencia y el producto cartesiano. Para BD relacionales se suman la selecci√≥n, proyecci√≥n y el join. La sintaxis define que s√≠mbolos se utilizan para cada operador y que par√°metros recibe. Y la sem√°ntica define cual es el esquema resultado, cual es la instancia del resultado y que condiciones deben cumplir para que se pueda aplicar el operador. Selecci√≥n - ùùàùúΩ(ùíì) Permite obtener las tuplas que cumplen una cierta condici√≥n. Dada una relaci√≥n R y una condici√≥n ∆ü, la selecci√≥n ùúéùúÉ (ùëÖ) da como resultado otra relaci√≥n con mismo esquema que R y con una instancia del conjunto de tuplas que cumplen con ∆ü. Proyecci√≥n - ùùÖùú∂(ùíì) Permite obtener las tuplas con un cierto conjunto de atributos. Devuelve una relaci√≥n con distinto esquema. Donde Œ± es la lista de atributos que conforman el esquema devuelto. Uni√≥n ‚Äì R U S Obtener la uni√≥n de 2 relaciones (R y S) tomadas de un conjunto de tuplas. Las relaciones R y S DEBEN tener el mismo esquema. Diferencia ‚Äì R ‚Äì S Obtener la diferencia de dos relaciones (R y S) tomadas como conjunto de tuplas. Las relaciones R y S DEBEN tener el mismo esquema. Producto Cartesiano ‚Äì R x S Obtener el producto cartesiano de dos relaciones. El resultado es otra relaci√≥n cuyo esquema es (E1 + E2) y las tuplas son generadas por todas las combinaciones posibles de las tuplas de R con las de S. Hasta el momento se mostraron los operadores b√°sicos. Los siguiente se pueden derivar de aplicar los anteriores. Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 12 JOIN ‚Äì R |x|∆ü S Combina tuplas de dos relaciones a trav√©s de una condici√≥n ∆ü sobre los atributos. Es exactamente lo mismo que hacer un producto cartesiano entre R y S y luego sobre el resultado hacer una selecci√≥n con ∆ü. Una variante es el JOIN NATURAL (R*S) donde la condicion es de igualdad entre los atributos de igual nombre. DIVISION - R % S La relaci√≥n da como resultado otra relaci√≥n con esquema (A1‚Ä¶An) y su contenido son las tuplas tomadas a partir de R tales que su valor est√° asociado a TODOS los valores de S. Importante: Si bien se exige que la soluci√≥n este relacionada con todos los valores de S, no se exige que lo este solamente con esos valores. Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 13 C√°lculo Relacional Es un lenguaje o familia de lenguajes de consultas sobre modelos relacionales basadas en formulas l√≥gicas de primer orden para definir conjuntos. Una consulta es una especificaci√≥n por comprensi√≥n de un conjunto de tuplas. Existen dos sublenguajes en el calculo relacional: ÔÇ∑ TUPLAS: El universo est√° formado por tuplas ÔÇ∑ DOMINIOS: El universo est√° formado por valores individuales C√°lculo de Tuplas Una expresi√≥n CRT est√° compuesta por : ÔÇ∑ Variable tupla que caracteriza el resultado. Se especifica la estructura de dicha variable. ÔÇ∑ Condici√≥n que caracteriza las tuplas resultado en t√©rminos de l√≥gica de primer orden. ÔÇ∑ ‚ÄúCuidados‚Äù para escribir formulas que realmente describan los conjuntos que nos interesan. < ùë°1ùê¥1, ‚Ä¶ , ùë°ùëõ ùê¥ùëõ > | ùúë(ùë°1 ‚Ä¶ ùë°ùëõ ) Donde el universo utilizado es el conjunto de todos los posibles. Es decir, es un conjunto infinito que contiene tuplas de cualquier aridad, tuplas con cualquier dominio en cualquier posici√≥n. La formula ùúë(ùë°1 ‚Ä¶ ùë°ùëõ ) es una f√≥rmula l√≥gica de primer orden donde los predicados corresponden a relaciones o comparaciones entre atributos, las variables son tuplas y no existen funciones del usuario. Las f√≥rmulas a utilizar pueden ser de: ùë°1 < ùëúùëù > ùë°2 | ùëúùëù = =, <, >, ‚â† ùëÉùëñ ùë•ùëñ | ùëÉùëñ ùëíùë† ùë°ùëéùëèùëôùëé ùõº < ùê∂ùëÇùëÅùëÅ > ùõΩ | ùõº, ùõΩ ùëìùëúùëüùëöùë¢ùëôùëéùë† ~ùõº | ùõº ùëíùë† ùëìùëúùëüùëöùë¢ùëôùëé ‚àÉùë•ùëñùúï | ùúï ùëíùë† ùëìùëúùëüùëöùë¢ùëôùëé ‚àáùë•ùëñ ùúï | ùúï ùëíùë† ùëìùëúùëüùëöùë¢ùëôùëé En el c√°lculo relacional, puede darse que se obtengan formulas inseguras, estas permiten resultados infinitos en consultas CRT. Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 14 Llamemos Dominio de Expresi√≥n CRT al conjunto de todos los valores que aparecen como valores constantes en la expresi√≥n o bien que existen en cualquiera de las relaciones a las que se hace referencia en la expresi√≥n. F√≥rmulas Seguras Una expresi√≥n CRT es SEGURA si todos los valores de su resultado pertenecen al dominio de la expresi√≥n. Para chequear si una formula es segura: ÔÇ∑ Pensar en la formula traducida con conectores binarios l√≥gicos. ÔÇ∑ Si f es tipo ùúó1 ÀÖ ‚Ä¶ ÀÖ ùúóùëõ en cada ùúóùëñ deben aparecer TODAS las variables libres en un predicado NO NEGADO. ÔÇ∑ Si f es tipo ùúó1 ÀÑ ‚Ä¶ ÀÑ ùúóùëõ cada variable debe aparecer en al menos una ùúóùëñ en un predicado NO NEGADO. Calculo de Dominios Las formulas son del tipo { t1‚Ä¶tn / Œ± } donde ti es o una variable o una constante. Si es variable, aparece libre en Œ±. La ventaja es que permite expresiones m√°s compactas que las de CRT. Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 15 SQL Es un lenguaje procedural que opera sobre conjunto de tuplas. Su poder de expresi√≥n incluye el Algebra Relacional, y la extiende. Se identifican dos lenguajes dentro del SQL. El DDL (Data Definition Language) y el DML (Data Manipulation Language). El primero permite crear, modificar y eliminar objetos de la base de datos. Mientras que el √∫ltimo permite crear, modificar, eliminar y recuperar datos de una base de datos. La sentencia SELECT Esta sentencia es utilizada para obtener tuplas de la base. ÔÇ∑ Ai son nombres de atributos ÔÇ∑ Ri son nombres de relaciones ÔÇ∑ P es una condicion Order By Ordenar las tuplas devueltas por uno o varios atributos. Dependiendo si se le agrega ASC o DESC luego del atributo es como realizar√° el ordenamiento. Distinct Esta clausular filtra los elementos repetidos. Joins Un join se puede realizar agregando en la condicion P, las condiciones del join. Es decir, estableciendo que atributos deben ser iguales entre s√≠ para poder hacer el join. A su vez, se puede utilizar NATURAL JOIN que lo que hace autom√°ticamente es filtrar por atributos de distintas tablas que tengan el mismo nombre. Existen otros tipos de JOIN pero no los utilizamos con normalidad. Estos son: ÔÇ∑ LEFT JOIN: se agrega, para cada tupla de T1 que no satisface la condici√≥n de JOIN con NINGUNA de T2, una fila con NULOS en las columnas de T2 ÔÇ∑ RIGHT JOIN: an√°logo a Left Join pero al rev√©s. ÔÇ∑ FULL JOIN: Uni√≥n de Left y Right Renombrar Atributos A veces es muy practico y otras necesario renombrar atributos para evitar ambig√ºedades en la consulta SQL. Se pueden renombrar tanto atributos como tablas. SELECT A1, A2, ‚Ä¶ , An FROM R1, R2, ‚Ä¶ , Rm WHERE P Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 16 Union Si tengo dos consultas S y T, quiero hacer la uni√≥n de las dos. S UNION T. La uni√≥n elimina las tuplas repetidas. Diferencia Para utilizar u obtener una diferencia entre dos conjuntos de tuplas puede realizar la consulta S EXCEPT T o puedo utilizar el operador NOT IN cuando creo la condici√≥n Funciones ÔÇ∑ Count(atributo) ÔÇ∑ Max (atributo) ÔÇ∑ Min(atributo) Todas trabajan sobre conjuntos de tuplas no sobre una tupla individual. Consultas Anidadas Puedo agregar una nueva consulta en la condicion de otra consulta utilizando los operadores IN y EXISTS. Group By Es una clausula mas que se agrega al final de la consulta. Si se utiliza la clausula, en las expresiones del SELECT solo puedo utilizar atributos que se encuentran dentro del group by, funciones de agregaci√≥n sobre esos atributos, o expresiones aritm√©ticas que utilicen los anteriores. Having Se pueden especificar condiciones sobre los grupos formados por Group By. Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 17 Dise√±o de Base de Datos Relacional Pautas Informales Existen 4 medidas informales para verificar la calidad de los dise√±os de base de datos relacionales. Sem√°ntica de los Atributos Dise√±ar un esquema de relaci√≥n de modo que sea f√°cil de explicar su significado. No combinar atributos de varios tipos de entidades y tipos de v√≠nculos en una sola relaci√≥n. Reducci√≥n de Valores Redundantes El hecho de que existan valores redundantes implica que haya anomal√≠as de inserci√≥n, eliminaci√≥n o modificaci√≥n. Dise√±ar los esquemas de las relaciones de modo que no haya anomal√≠as. En el caso de que existan anomal√≠as, se√±alarlas con claridad a fin de que los programas que actualicen la BD operen correctamente. Reducci√≥n de Valores Nulos La existencia de valores nulos en tuplas generan desperdicio de espacio, dificultad para entender el significado, problemas al aplicar funciones agregadas, existencia de multiples interpretaciones. Hasta donde sea posible, evitar incluir en una relaci√≥n atributos cuyos valores pueden ser nulos. Si no es posible, asegurarse de que se apliquen solo en casos excepcionales y no a la mayor√≠a de las tuplas en una relaci√≥n. Inexistencia de Tuplas Err√≥neas Dise√±ar los esquemas de modo que puedan reunirse por condicion de igualdad sobre atributos claves, para garantizar que no se formen tuplas err√≥neas. Dependencias Funcionales Una dependencia funcional ùëëùëì ‚à∂ ùëã ‚Üí ùëå entre dos conjuntos de atributos X e Y que son subconjuntos de R, especifica una restricci√≥n sobre las posibles tuplas que formar√≠an una instancia de R. Sean t1 y t2 tuplas de R tales que ùë°1 ùëã = ùë°2 ùëã ‚Üí ùë°1 ùëå = ùë°2 ùëå Si X es una clave candidata de R, entonces ùëëùëì ‚à∂ ùëã ‚Üí ùëå para cualquier subconjunto de atributos Y de R. Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 18 Si ùëëùëì ‚à∂ ùëã ‚Üí ùëå en R, no implica que se deba cumplir ùëëùëì ‚à∂ ùëå ‚Üí ùëã Clausura de F ‚Äì F+ Sea F el conjunto de dependencias funcionales especificadas sobre el esquema relaci√≥n R. Llamaremos F+ como Clausura de F al conjunto de todas las dependencias funcionales que se cumplen en todas las instancias que satisfacen F. Reglas de Inferencia ÔÇ∑ Reflexiva : ùë†ùëñ ùëã ‚ÜÉ ùëå ‚Üí ùëã ‚Üí ùëå ÔÇ∑ De Aumento : ùëã ‚Üí ùëå ‚Üí ùëãùëç ‚Üí ùëåùëç ÔÇ∑ Transitiva : ùëã ‚Üí ùëå, ùëå ‚Üí ùëç ‚Üí ùëã ‚Üí ùëç ÔÇ∑ Descomposici√≥n : ùëã ‚Üí ùëåùëç ‚Üí ùëã ‚Üí ùëå ÔÇ∑ Uni√≥n : ùëã ‚Üí ùëå, ùëã ‚Üí ùëç ‚Üí ùëã ‚Üí ùëåùëç ÔÇ∑ Pseudo-transitiva : ùëã ‚Üí ùëå, ùëäùëå ‚Üí ùëç ‚Üí ùëäùëã ‚Üí ùëç Definimos X+ como el conjunto de atributos determinados funcionalmente por X. El algoritmo para obtener este conjunto es el siguiente: Dos conjuntos de dependencias funcionales E y F son equivalentes si y solo si se cumple que E+ = F+. Es decir, todas las dependencias funcionales en E se pueden inferir de F y E cubre a F. Para determinar si F cubre a E: Para cada ùëëùëì ‚à∂ ùëã ‚Üí ùëå perteneciente a E, calculamos X+ (F) y verificamos que X+ incluya los atributos en Y. Conjunto Minimal Un conjunto F de dependencias funcionales es Minimal si cumple: ÔÇ∑ Toda ùëëùëì ‚à∂ ùëã ‚Üí ùëå en F tiene un solo atributo a la derecha ÔÇ∑ No se puede reemplazar ninguna ùëëùëì ‚à∂ ùëã ‚Üí ùê¥ ∆ê F por ùëëùëì ‚à∂ ùëå ‚Üí ùê¥ donde Y ‚ÜÉ X X+ := X REPETIR viejo X+ := X+ para cada ùëëùëì ‚à∂ ùëå ‚Üí ùëç en F si Y ‚ÜÉ X+ entonces X+ := X+ U Z HASTA (viejo X+ == X+) Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 19 ÔÇ∑ No podemos quitar dependencias funcionales de F y seguir teniendo un conjunto de dependencias funcionales equivalente. Algoritmo de Cubrimiento Minimal 1. Hacer G := F 2. Reemplazar cada ùëëùëì ‚à∂ ùëã ‚Üí ùê¥1ùê¥2 ‚Ä¶ ùê¥ùëõ en G por las n ùëëùëìùë† ‚à∂ ùëã ‚Üí ùê¥ùëñ 3. Para cada ùëëùëì ‚à∂ ùëã ‚Üí ùê¥ restante en G i. Para cada atributo B que sea un elemento de X 1. Calcular (X-B)+ respecto a G 2. Si (X-B)+ contiene a A, reemplazar ùëëùëì ‚à∂ ùëã ‚Üí ùê¥ por ùëëùëì ‚à∂ ùëã ‚àí ùêµ ‚Üí ùê¥ 4. Para cada ùëëùëì ‚à∂ ùëã ‚Üí ùê¥ en G a. Calcular X+ respecto a ùê∫ ‚àí ùëã ‚Üí ùê¥ b. Si X+ contiene a A, eliminar ùëã ‚Üí ùê¥ de G Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 20 Formas Normales La normalizaci√≥n es un proceso durante el cual los esquemas relacionales insatisfactorios se descomponen repartiendo sus atributos en esquemas relacionales mas peque√±os que poseen propiedades deseables. En este proceso el esquema se somete a una serie de pruebas para ‚Äúcertificar‚Äù si pertenece o no a una cierta forma normal. Una forma normal no garantiza, sin considerar otros factores un buen dise√±o de BD. Para ello se debe considerar la propiedad de Join sin perdida y la preservaci√≥n de dependencias. Claves y Superclaves Una superclave es un conjunto de Atributos S ‚ÜÉ R tal que no existen 2 tuplas t1 y t2 en ning√∫n esquema R tal que t1[S] = t2[S]. Una clave es una superclave que si se le quita alguno de sus atributos, deja de ser superclave. Si una relaci√≥n tiene mas de una clave, cada una es clave candidata. Una de ellas, elegida arbitrariamente es designada como clave primaria. El resto son secundarias. Atributos y Dependencias Un atributo del esquema relaci√≥n R es primo si es miembro de alguna clave de R. ùëëùëì ‚à∂ ùëã ‚Üí ùëå es total si la eliminaci√≥n de cualquier atributo A de X hace que la dependencia funcional deje de ser v√°lida. O sea, no tiene atributos redundantes a la izquierda. ùëëùëì ‚à∂ ùëã ‚Üí ùëå es parcial si es posible eliminar un atributo A de X y la dependencia funcional sigue siendo v√°lida. ùëëùëì ‚à∂ ùëã ‚Üí ùëå es transitiva si existe un subconjunto de atributos Z que no sea un subconjunto de cualquier clave de R y se cumplen tanto X ‚Üí ùëç como ùëç ‚Üí ùëå Primera Forma Normal (1NF) Los dominios de los atributos deben incluir solo valores atomicos (no pueden ser multivaluados ni compuestos). Segunda Forma Normal (2NF) Un esquema relacional R esta en 2NF si ning√∫n atributo no primo A de R, depende parcialmente de cualquier clave de R. Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 21 Tercera Forma Normal (3NF) Un esquema relacional R esta en 3NF si esta en 2NF y ning√∫n atributo no primo de R depende transitivamente de una clave de R. Es decir R esta en 3NF si siempre que una dependencia funcional ùëëùëì ‚à∂ ùëã ‚Üí ùê¥ se cumple en R o que X es Superclave o de lo contrario A es atributo primo de R. Forma Normal Boyce-CODD (BCNF) Un esquema relacional esta en BCNF si siempre que una ùëëùëì ‚à∂ ùëã ‚Üí ùê¥ se cumple en R, X es superclave de R. Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 22 Algoritmos de Dise√±o Descomposici√≥n de Relaciones y Joins Sin Perdida Sea R = (A1,‚Ä¶,An) el esquema relacional universal que contiene TODOS los atributos de la BD. D = (R1,‚Ä¶,Rm) se obtiene mediante el algoritmo de descomposici√≥n utilizando dependencias funcionales. Proyecci√≥n: Dado un conjunto de dependencias funcionales de F sobre R, la proyecci√≥n de F sobre Ri , ùúãùëÖùëñ (ùêπ) donde Ri es un subconjunto de R, es el conjunto de ùëëùëìùë† ‚à∂ ùëã ‚Üí ùëå en F+ tal que los atributos en X U Y est√©n todos contenidos en Ri. Una descomposici√≥n D de R preserva dependencias respecto a F si cumple: ùúãùëÖ1(ùêπ) , ùúãùëÖ2(ùêπ) , ‚Ä¶ , ùúãùëÖùëö (ùêπ) + = ùêπ + Una descomposici√≥n D = (R1,‚Ä¶,Rm) de R tiene la propiedad de JSP respecto al conjunto de dependencias funcionales F sobre R, si por cada estado de relaci√≥n r de R que satisfaga F, se cumple ùúãùëÖ1(ùëü) , ùúãùëÖ2 (ùëü) , ‚Ä¶ , ùúãùëÖùëö (ùëü) = ùëü. Decimos que D = (R1,R2) de R tiene JSP respecto a F sobre R si y solo si: - si ùëÖ1 ‚à© ùëÖ2 ‚Üí ùëÖ1 ‚àí ùëÖ2 ùúñ ùêπ + - o ùëÖ1 ‚à© ùëÖ2 ‚Üí ùëÖ2 ‚àí ùëÖ1 ùúñ ùêπ + Descomposici√≥n en 3NF con pres de dependencias 1. Encontrar un cubrimiento Minimal G para F 2. Para cada miembro izquierdo X de una dependencia funcional de G a. Crear esquema relacional {X ‚à™ A1 ‚à™‚Ä¶‚à™ Am} en D, donde X ‚Üí Ai son las √∫nicas dependencias con X como miembro izquierdo. 3. Colocar cualquier atributo restante en un solo er para asegurar la prop de preservaci√≥n de dependencias. Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 23 Test Join Sin Perdidas (Test JSP) 1. Crear matriz S con fila i para cada relaci√≥n Ri en D y columna j por cada atributo Aj en R. 2. S (i, j) = Bij 3. Para cada fila i a. Para cada columna j i. Si Ri incluye Aj entonces S(i,j) = aj 4. Repetir hasta que no se modifique S a. Para cada df X ‚Üí Y en F i. Igualar los simbolos de los atributos de Y, para aquellas filas que coinciden en los atributos X 5. Si una fila tiene todos sus simbolos ‚Äúa‚Äù, D es con JSP. Descomposici√≥n en BCNF con JSP 1. Hacer D := { R } 2. Mientras haya un esquema relacional Q en D que no este en BCNF a. Escoger un er Q b. Encontrar una df X‚Üí ùëå en Q que viole BCNF c. Reemplazar Q en D por dos esquemas (Q ‚Äì Y) y (X U Y) Descomposici√≥n en 3NF con JSP y Pres. Dependencias 1. Encontrar cubrimiento Minimal de G para F 2. Para cada miembro X (izq) de una dependencia funcional que aparezca en G. Crear un esquema relacional l {X ‚à™ A1 ‚à™‚Ä¶‚à™ Am} en D, donde X ‚Üí Ai son las √∫nicas dependencias en G con X como miembro izquierdo 3. Colocar cualquier atributo correspondiente en un solo esquema r. 4. Si ninguno de los er contiene una clave de R, crear un er adicional que contenga atributos que formen una clave. Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 24 Dependencias Multivaluadas y Cuarta Forma Normal Si tenemos 2 o m√°s atributos multivaluados independientes en el mismo esquema relacional, tendremos que repetir todos los valores de uno de los atributos con cada valor del otro atributo, para que las tuplas de la relaci√≥n sigan siendo consistentes. Esta restricci√≥n se especifica con una dependencia multivaluada. Una ùëëùëöùë£ ùëã ‚Üí> ùëå especificada sobre el esquema relacional R, especifica la siguiente restricci√≥n sobre cualquier relaci√≥n r de R. Si existen dos tuplas t1 y t2 en r tales que t1(X)=t2(X) entonces deber√°n existir 2 tuplas t3 y t4 en r con las siguientes propiedades: ÔÇ∑ t3 X = t4 X = t1 X = t2 X ÔÇ∑ t3 Y = t1 Y y t4 Y = t2 Y ÔÇ∑ t3 R ‚àí XY = t2 R ‚àí XY y t1 R ‚àí XY = t4 R ‚àí XY Una dependencia multivaluada es trivial si se cumple que Y es un subconjunto de X, o si la uni√≥n de X con Y es R. Si existen dependencias Multivaluadas NO TRIVIALES en una relaci√≥n, tendremos valores redundantes en las tuplas. Cuarta Forma Normal Un er R esta en 4NF respecto a un conjunto de dependencias F si para cada dependencia multivaluada no trivial en F+, X es una superclave de R. Descomposici√≥n con JSP Sea D = (R1,R2) de R tiene JSP respecto a F sobre R si y solo si ÔÇ∑ La dmv (R1 ‚à© R2) ->> (R1 - R2) est√° en F+ √≥ ÔÇ∑ La dmv (R1 ‚à© R2) ->> (R2 ‚Äì R1) est√° en F+ Algoritmo de Descomposici√≥n en 4NF con JSP 1. Hacer D := { R } 2. Mientras haya un esquema relacional Q en D que no est√© en 4NF a. Comenzar i. Escoger un esquema relacional Q ii. Encontrar una dmv no trivial X->> Y que viole 4NF iii. Reemplazar Q en D por dos esquemas (Q-Y) y (X U Y) b. Fin Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 25 Estrategias de un DBMS Procesamiento y Optimizaci√≥n de Consultas Organizaci√≥n y Acceso a los datos Que estructuras de datos suelen implementar los manejadores y como se utilizan A nivel f√≠sico se cuenta con: ÔÇ∑ Discos Conjuntos de Bloques de tama√±o fijo que son direccionables a trav√©s de alguna forma de direcci√≥n por alguna instrucci√≥n espec√≠fica (READ). ÔÇ∑ Particiones Subconjunto continuo de los bloques de un disco ÔÇ∑ File System (FS) Estructura de datos que facilita el acceso del S.O a los distintos bloques de la partici√≥n. ÔÇ∑ Archivos Estructura l√≥gica que se construye sobre el FS. Es la que usualmente utilizan los programas de aplicaci√≥n. Los DBMS re-implementan lo anterior mencionado a su gusto. Toman una partici√≥n del disco o a lo sumo un gran archivo sobre el FS y usan esa √°rea como SU disco. Re-implementan las estructuras de datos y sus algoritmos de manipulaci√≥n, los algoritmos de sorting y los mecanismos de buffering y paginado. Para evitar utilizar operaciones de acceso a disco (costosas) al utilizar archivos secuenciales, se usa otro tipo de estructura sobre el disco, llamada √çndices. Tipos de √çndices ÔÇ∑ Datos f√≠sicamente ordenados o Primarios Archivo ordenado por la clave primaria de la tabla. Con cada clave se guarda un puntero al bloque de disco que contiene el registro. o De agrupamiento (cluster) Es un archivo ordenado por atributo no clave. Se usan para agrupar los datos que tienen un mismo valor en un atributo. ÔÇ∑ Datos f√≠sicamente no ordenados o Secundarios El puntero es a un registro o a un bloque. Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 26 Las estructuras t√≠picas para los √≠ndices son el HASH que tiene un muy buen comportamiento en la inserci√≥n y en la recuperaci√≥n por condiciones de igualdad, pero no funciona bien para condiciones con relaciones de orden. Y por otro lado est√°n los arboles B y B+. Estos tienen buen comportamiento en recuperaci√≥n tanto por condiciones de igualdad como de orden. Tiene un buen comportamiento en la inserci√≥n, pero tienen la desventaja que ocupan m√°s espacio en disco. La comparaci√≥n entre estructuras se realiza en base a la cantidad de operaciones b√°sicas que se utilizan para ejecutar una operaci√≥n en la estructura (solo operaciones de I/O) y a su vez se considera que un bloque de disco puede almacenar varios nodos de una estructura dada, y que el acceso se hace habitualmente a trav√©s de buffers que leen simult√°neamente m√°s de un bloque. Procesamiento de consultas Diferentes algoritmos para implementar los operadores del algebra relacional Proceso de Optimizaci√≥n o Generaci√≥n del Algebra (√Årbol Can√≥nico) o Generaci√≥n de planes l√≥gicos (Optimizaci√≥n Heur√≠stica) Aplicaci√≥n de determinadas estrategias y consultas al catalogo para tama√±os de las relaciones para transformar el √°rbol original. o Generaci√≥n de planes f√≠sicas (Optimizaci√≥n por Costos) Asociar a cada operaci√≥n de los planes l√≥gicos, una o mas implementaciones. La implementaci√≥n depende de las estructuras de datos disponibles. o Selecci√≥n del Plan Final (Optimizaci√≥n por Costos) Evaluaci√≥n de los planes f√≠sicos generados, en base a las cantidades de operaciones de I/O que realiza cada algoritmo. Optimizaci√≥n de Consultas Estrategias que utiliza un manejador para modificar las consultas y para elegir los algoritmos a ejecutar. Optimizaci√≥n Heur√≠stica Basada en equivalencia de la expresi√≥n del algebra y ciertas estrategias b√°sicas para limitar el tama√±o de los resultados. Se basa en aplicar equivalencias de los operadores del algebra de forma que las selecciones se apliquen lo antes posible, y que las ramas izquierdas de los joins, sean m√°s chicas que las derechas. Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 27 Reglas: 1. Cambiar las selecciones conjuntivas por una ‚Äúcascada‚Äù de selecciones simples 2. Mover las selecciones lo m√°s abajo posible en el √°rbol. 3. Poner a la izquierda de los productos las hojas que generen menos tuplas 4. Cambiar secuencias de selecciones y productos por joins. 5. Mover las proyecciones lo m√°s abajo posible en el √°rbol, agregando las proyecciones que sean necesarias. Optimizaci√≥n por Costos Basada en estimaciones y datos del catalogo que permiten seleccionar un mejor plan de proceso. El plan f√≠sico asocia a cada operaci√≥n que aparece en un plan l√≥gico, una implementaci√≥n. Como se pueden considerar diferentes implementaciones en cada operador, un mismo plan l√≥gico puede originar distintos planes f√≠sicos. Es necesario estimar el costo de los diferentes planes, y elegir el de costo m√≠nimo. Para evaluar el costo es necesario considerar ciertos par√°metros que tienen influencia en el c√°lculo de la cantidad de operaciones. Implementaci√≥n de los operadores Es importante saber cu√°l es la estrategia de implementaci√≥n. Si es PIPELINED, hay operadores que se ejecutan simult√°neamente y pueden pasarse los resultados a medida que se generan. En cambio, si es NO PIPELINED, los operadores se ejecutan secuencialmente y es necesario grabar los resultados intermedios. La estrategia puede depender de los operadores, nosotros asumimos que la selecci√≥n y el join son NO PIPELINED, mientras que la proyecci√≥n es PIPELINED. En el calculo de los costos, se considera la lectura y la grabaci√≥n en disco. Siempre se realizan las operaciones de a bloque. Los costos de lectura dependen de la organizaci√≥n de los datos pero el costo de grabaci√≥n siempre es el costo de grabar todo el resultado R. En los algoritmos, se considera la lectura, pero a ello se le debe agregar el costo de grabaci√≥n. Tipos de Implementaci√≥n o Selecci√≥n con condici√≥n C Puede ser b√∫squeda lineal o binaria. La primera consiste en leer cada registro, y si Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 28 cumple la condici√≥n se pone en el resultado. La segunda, consiste en leer el bloque medio y en funci√≥n de la condici√≥n leer el del medio de la primera o segunda mitad. La ultima forma, requiere que los datos est√©n ordenados. o Selecci√≥n con Indices Se puede realizar por Indice Primario o Cluster, donde los registros deben estar ordenados y consiste en acceder por el √≠ndice y recuperar los registros que cumplen la condici√≥n. Luego, se puede realizar con Hash donde los costos de lectura son constantes (1 o 2) pero requiere que sean condiciones de igualdad sobre los √≠ndices. O se puede implementar como Indices Secundarios con B+ y el costo de lectura es un moco m√†s elevado que las anteriores, pero no tiene restricciones. o Joins con condici√≥n de igualdad en conjuntos de atributos o Loop Anidado por Registros Para cada registro de R, se accede a todos los bloques de S y se combina ese registro en R con todos los de S. o Loop Anidado por Bloques Para cada bloque de R combinar todos los registros de ese bloque con los de S, luego pasar al siguiente bloque de S. o Sort-Merge Join Recorrer R y S, en paralelo combinando los registros. Para este caso, se deben tener los registros ordenados. Si no es asi, se deben agregar los costos de ordenaci√≥n. o Index Join (Single Loop) Recorrer R y acceder por el √≠ndice a S. Para esto, se debe tener un √≠ndice para S. Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 29 Control de Concurrencia Coordinaci√≥n de procesos concurrentes que operan sobre datos compartidos y que podr√≠an interferir entre ellos. Transacciones Operaciones complejas que se ven como una sola A cada proceso que se ejecuta se le llama transacci√≥n si cumple las propiedades ACID ÔÇ∑ Atomicidad Desde el punto de vista del estado, o se ejecuta o no se ejecuta ÔÇ∑ Consistencia Siempre lleva a la base desde un estado consistente a otro ÔÇ∑ Aislamiento Una transacci√≥n no debe interferir con otra ÔÇ∑ Durabilidad Los cambios de una transacci√≥n confirmada deben ser permanentes en la base Para que una transacci√≥n cumpla con ACID la transacci√≥n debe pasar o seguir el siguiente ciclo: Concurrencia Que debe considerar el manejador para que varias transacciones se ejecuten simult√°neamente y produzcan resultados concretos en la base. Activa Parcialmente confirmada Confirmada Completada Falla Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 30 Para el control de la concurrencia se necesita el concepto de transacci√≥n como hemos definido anteriormente y a su vez las siguientes operaciones y conceptos. ÔÇ∑ Read ‚Äì ri(x) La transacci√≥n i lee el √≠tem X de la base ÔÇ∑ Write ‚Äì wi(x) La transacci√≥n i escribe el √≠tem X de la base ÔÇ∑ Commit - ci La transacci√≥n i confirma que todas sus modificaciones deben ser permanentes ÔÇ∑ Abort - ai La transacci√≥n i indica que ninguna de sus modificaciones deben ser permanentes. ÔÇ∑ ROLLBACK Es la acci√≥n de recuperar el estado anterior de la base frente a un abort de una transacci√≥n. Manejador de Transacciones Recibe instrucciones desde los programas, las reordena sin cambiar el orden relativo de los read y write, agrega instrucciones si es necesario (ni read ni write), hace demorar algunas ejecuciones tratando de implementar ACID mientras pueda. Definimos una HISTORIA como la ordenaci√≥n de todas las operaciones que intervienen en las transacciones de un determinado conjunto de transacciones, siempre que estas aparezcan en el mismo orden que en la transacci√≥n. En una historia se pueden encontrar OPERACIONES EN CONFLICTO, que cumplen a la vez ÔÇ∑ Pertenecen a distintas transacciones. ÔÇ∑ Acceden al mismo √≠tem. ÔÇ∑ Una de ellas es un write. Decimos que una historia es COMPLETA si tiene todas las operaciones de las transacciones involucradas y las operaciones en conflicto aparecen en el mismo orden. T1 lee de T2 en H si w2(x) est√° antes de r1(x) y en el medio no hay otro wj(x) tal que cj este en H y tampoco existe un a2. Serializaci√≥n Si las transacciones se ejecutaran siempre en forma serial, no habr√≠a concurrencia pero los datos siempre ser√≠an correctos. Si las historias son entrelazadas puede suceder que queden datos err√≥neos que no se puedan corregir o que si una transacci√≥n aborta otra tambi√©n tenga que abortar. Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 31 Una historia es SERIALIZABLE si es equivalente a una historia serial con las mismas transacciones. La primera noci√≥n de equivalencia es la intuitiva, es decir dos historias son equivalentes si dejan la base en el mismo estado. Tambi√©n se puede resolver por equivalencia, si dos historias tienen las operaciones en conflicto en el mismo orden, tambi√©n son equivalentes. Luego se puede definir un tercer criterio que es el de las vistas, si cada Ti lee de las mismas Tk en H y H¬¥, son equivalentes. Testeo de Seriabilidad por Conflictos El m√©todo consiste en construir un grafo de Seriabilidad o precedencia de la siguiente forma: 1. Poner un nodo para cada transacci√≥n en la historia 2. Si rj(x) esta despu√©s de wi(x), entonces hay un arco de Ti a Tj 3. Si wj(x) esta despu√©s de ri(x), entonces hay un arco de Ti a Tj 4. Si wj(x) est√° despu√©s de wi(x), entonces hay un arco de Ti a Tj. Siempre se pone un arco si hay una pareja de operaciones en conflicto, desde la primera transacci√≥n a la segunda. Si el grafo es ac√≠clico, la historia es serializable. El manejador debe asegurar la construcci√≥n de historias serializables, recuperables y que no tengan abortos en cascada. La forma de realizar esto es demorar las operaciones en conflicto con otras anteriores hasta que se terminen. Puede ser con LOCKING o con TIMESTAMPS. Una historia es RECUPERABLE si ninguna transacci√≥n confirma hasta que se confirmaron todas las transacciones desde las cuales se leyeron √≠tems. Es decir, los commits est√°n en el mismo orden que las lecturas. Una historia EVITA ABORTOS EN CASCADA si ninguna transacci√≥n lee de transacciones no confirmadas. Es decir, los commits tienen que estar antes de los reads siguientes. Una historia es ESTRICTA si ninguna transacci√≥n lee o escribe hasta que todas las transacciones que escribieron ese √≠tem fueron confirmadas. Los commits deben estar antes que los reads o writes de las siguientes. T√©cnicas de Locking Consideramos dos operaciones nuevas en una transacci√≥n Ti: locki(x) y unlocki(x). Cuando se ejecuta locki(x) el DBMS hace que cualquier lockj(x) no termine hasta que Ti ejecute unlocki(x). El lock puede ser binario como mencionamos recientemente, siendo f√°cil de implementar pero que tiene la desventaja de negar la lectura a otra transacci√≥n aunque no sea necesario. Y si no puede ser Read/Write Lock, aqu√≠ se deben considerar tres operaciones read_locki(x), write_locki(x), unlocki(x). Este tipo tiene la ventaja de que permite que varias operaciones Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 32 hagan un read_lock simult√°neamente sobre el mismo √≠tem. En cambio, es un poco m√°s complicado de implementar. Reglas de uso de LOCKS ‚Äì Protocolos de Locking Si bien existen reglas para usar los distintos tipos de locks anteriores, estas por si solas no garantizan la Seriabilidad de la historia. Entonces, mediante un protocolo de locking, se define un conjunto de reglas que sean m√°s fuertes y si garanticen la Seriabilidad. En el protocolo 2PL ‚Äì Two Phase Locking existen dos fases en una transacci√≥n. La primera la fase de crecimiento donde sea crean los locks y luego la fase de contracci√≥n donde se liberan los locks. ÔÇ∑ 2PL BASICO Solo exige que se cumplan las dos fases, es muy simple de implementar pero es susceptible a los deadlocks. ÔÇ∑ 2PL CONSERVADOR Exige que todos los locks se hagan antes del comienzo de la transacci√≥n. No pueden ocurrir deadlocks pero existe la predeclaraci√≥n de todos los √≠tems que se van a leer o grabar. ÔÇ∑ 2PL ESTRICTO Exige que no se libere ning√∫n write_lock hasta despu√©s de terminar la transacci√≥n. Garantiza historias estrictas, pero pueden ocurrir deadlocks. ÔÇ∑ 2PL RIGUROSO Exige que no libere ning√∫n read_lock o write_lock hasta depues de terminar la transacci√≥n. Es mas simple de implementar que el estricto y pueden ocurrir deadlocks. Un DEADLOCK es cuando dos o m√°s transacciones esperan unas por otras. Para determinar si una historia tiene deadlocks, construir el grafo de espera (arco de T1 a T2 si T1 esta tratando de lockear un √≠tem que T2 tiene lockeado). Si el √°rbol tiene ciclos, entonces hay un deadlock. Para solucionar el problema de los DEADLOCKS, existen protocolos de prevenci√≥n, otros protocolos de detecci√≥n y otros de TimeOut. En los de detecci√≥n La idea es mantener un grafo de espera y si hay deadlocks, seleccionar la v√≠ctima y que aborte. Es √∫til para transacciones c√≠clicas. La idea del TimeOut es que si una transacci√≥n espera por demasiado tiempo, esta es abortada. Fundamentos de Bases de Datos 2009 Santiago Cotelo ‚Äì Facultad de Ingenier√≠a Page 33 Los protocolos de prevenci√≥n se basan en TIMESTAMPS (marcas de tiempo)","libVersion":"0.3.1","langs":""}