{"path":"Archivados/Programación Funcional/media/propuesta.pdf","text":"Programaci´on Funcional Prueba Escrita - 2019 Nombre: CI: 1. Dada la siguiente deﬁnici´on: foo a b c d e = fst (head [⊥, (a == b, a < d || c == e)]) El tipo m´as general es: (a) No tiene (b) foo :: (Ord a, Eq b) ⇒ a → a → b → a → b → Bool (c) foo :: (Ord a) ⇒ a → a → a → a → a → Bool (d) foo :: (Eq a, Eq b, Eq c, Eq e, Ord a, Ord d ) ⇒ a → b → c → d → e → Bool Respuesta: b) 2. Recuerde el tipo State de una m´onada de estado: data State s a = State {runState :: s → (a, s)} Dada la siguiente deﬁnici´on: bar :: Int → State Int Int bar i = get >>= λs → put (s ∗ i ) >> get >>= λs ′ → return (s ′ + s + 3 ∗ i ) ¿Cu´al de las siguientes aﬁrmaciones es correcta? (a) El resultado de evaluar (fst $ runState (bar 3) 5) es 29 (b) Evaluar (fst $ runState (bar 3) 5) diverge (c) El resultado de evaluar (fst $ runState (bar 3) 5) es 39 (d) El resultado de evaluar (fst $ runState (bar 3) 5) es 15 Respuesta: a) 1 3. Dada la siguiente deﬁnici´on: tk n = map snd ◦ box n ◦ zip [1 . .] ¿Cu´al de las siguientes implementaciones de box hace que tk sea equiva- lente a take (para cualquier lista)? (a) No hay implementaci´on posible de box para deﬁnir take as´ı (b) box n = takeWhile ((⩽ n) ◦ fst) (c) box n = ﬁlter ((⩽ n) ◦ fst) (d) box n (n ′, x ) = if n ⩽ n ′ then [x ] else [ ] Respuesta: b) 4. Dadas las siguientes deﬁniciones: data T a b c = T [T a b c ] | V a (b, c) foo h k (V x p) | k == x = [h p ] | otherwise = [ ] foo h k (T vs) = head $ map (foo h k ) vs bar = foo snd 8 $ T [V 8 (’a’, 6), T [ ], T [V 5 (’b’, 7), T [V 8 (’j’, 5)]]] ¿Cu´al de las siguientes aﬁrmaciones es correcta? (a) El c´odigo no compila (b) El resultado de evaluar bar es [6] (c) El resultado de evaluar bar es [6, 5] (d) El resultado de evaluar bar genera un error en tiempo de ejecuci´on Respuesta: b) 5. Implemente como un foldl la funci´on lookup :: Eq k ⇒ k → [(k , a)] → Maybe a que realiza una b´usqueda lineal en una lista de asociaciones. Por ejemplo: lookup 4 [(3, ’a’), (4, ’h’), (1, ’p’), (4, ’m’)] retorna (Just ’h’) lookup 4 [(3, ’a’), (6, ’h’), (1, ’p’), (2, ’m’)] retorna Nothing lookup k = foldl is Nothing where is (Just y) = Just y is r (x , y) | x == k = Just y | otherwise = r 2 6. Dada la siguiente deﬁnici´on: data C a = C (Bool , a) foo (C (True, x )) = x foo (C x ) = (fst x , False) Indique la opci´on correcta: (a) El c´odigo no compila (b) El resultado de evaluar (snd $ foo $ C (True, ⊥)) es False (c) El resultado de evaluar (snd $ foo $ C (False, ⊥)) es False (d) El resultado de evaluar (snd $ foo $ C (True, True)) es True Respuesta: c) 7. Dadas las siguientes deﬁniciones: data Tree a = Node (Tree a) (Tree a) | Leaf a foldT :: (b → b → b) → (a → b) → Tree a → b foldT ﬂ (Leaf x ) = ﬂ x foldT fn ﬂ (Node l r ) = fn (foldT fn ﬂ l ) (foldT fn ﬂ r ) ¿Cu´al de las siguientes aﬁrmaciones NO es correcta? (a) La aplicaci´on (foldT (+) (const 1)) retorna una funci´on que retorna la cantidad de hojas del ´arbol dado (b) La aplicaci´on (foldT max id ) retorna una funci´on que retorna el m´aximo elemento del ´arbol dado (c) La aplicaci´on (foldT (++) (:[ ])) retorna una funci´on que retorna una lista con los elementos producidos por una recorrida en orden del ´arbol dado (d) La aplicaci´on (foldT max (const 0)) retorna una funci´on que retorna la altura del ´arbol dado Respuesta: d) 8. Dadas las siguientes deﬁniciones: foo [ ] = id foo (x : xs) = foo xs ◦ (+1) bar xs = foo xs 0 ¿Cu´al de las siguientes aﬁrmaciones es correcta? (a) El resultado de evaluar (bar [1, 2, −4, 3, −8]) es 5 3 (b) El resultado de evaluar (bar [1, 2, −4, 3, −8]) es [2, 3, −3, 4, −7] (c) El resultado de evaluar (foo [ ] \"hola\") es \"hola\" (d) El c´odigo no compila Respuesta: a) 9. Dada la siguiente deﬁnici´on: foo f x = f $ f x ¿Cu´al de las siguientes opciones NO es correcta?: (a) foo id ≡ id (b) El tipo m´as general de foo es foo :: (a → a) → (a → a) (c) foo (∗2) 100 ≡ 400 (d) (Int → Bool ) → Int → Bool es instancia del tipo de foo. Respuesta: d) 10. Dada la siguiente deﬁnici´on: as = [ ] : map (1:) as Para cada una de las siguientes expresiones indique el resultado de su evaluaci´on o si la misma diverge (si pone diverge en todas las opciones anula la pregunta). (a) (take 4 as) [[],[1],[1,1],[1,1,1]] (b) (length ◦ tail ◦ tail $ as) diverge (c) (length ◦ head ◦ tail ◦ tail $ as) 2 (d) (head (foldr ((:) ◦ head ) [ ] (tail as))) 1 (e) (head (foldl ((:) ◦ head ) [ ] (tail as))) diverge (f) (take 4 $ ﬁlter ((<4) ◦ length) as) [[],[1],[1,1],[1,1,1]] (g) (length $ ﬁlter ((<4) ◦ length) as) diverge (h) (head ◦ tail $ map (λxs → zip xs as) as) [(1,[])] 4","libVersion":"0.3.1","langs":""}