{"path":"Bases de datos/pdfs/resumen_practico.pdf","text":"Fundamentos de Bases de Datos Resumen práctico Diego González 2014 diesgomo@gmail.com 2 3 1. Bases de Datos 1.1 Definiciones Básicas  Dato: Representación simbólica que ante la inexistencia de un contexto, carece de significado  Información: Datos interpretados (que poseen una semántica)  Sistema de Información (SI): Conjunto de componentes que interactúan con el objetivo de almacenar, recuperar y procesar datos e información con el fin de crear nueva información  Base de Datos (BD): Conjunto de datos relacionados entre sí  Metadatos: Reglas que determinan si una información pertenece a una BD  Sistema Manejador de Bases de Datos (DBMS): SW que administra BDs  Modelo: Lenguaje que permite describir: Aspecto Modelo Estructuras de Datos De datos Conceptual Restricciones de integridad Operaciones (sobre la estructura) 1.2 Bases de Datos  Ciclo de vida de una BD: Definición  Construcción  Manipulación (Diseño conceptual) (Diseño lógico) (Diseño físico) Estructura Carga de datos iniciales Explotación de datos Restricciones  Ventajas de uso de BDs: Aspecto Descripción Ventajas Definición De los datos abstractamente  Centralización  Abstracción (de programas- datos/operaciones)  Múltiples vistas Construcción Programación de la BD  Eficiencia de consultas  Enfoque declarativo de restricciones e integridad  Estandarización1 Manipulación Explotación de la BD  Datos compartidos  Control de concurrencia  Seguridad  Tolerancia ante fallas  Persistencia de datos consistentes (incluso de objetos) 1 De modelos y lenguajes que usan la BD 4  Uso no adecuado de BDs: Aspecto Descripción Costo de inversión Alto en HW, SW y capacitación Costo de administración De la BD y el DBMS Naturaleza de los datos Pocos datos o muy estables en el tiempo Performance crítica Sistemas de tiempo real No hay concurrencia  Componentes: Esquema Definición de la BD. Totalmente equivalente al Modelo Conceptual Instancia Estado de la BD y sus datos en un momento determinado 1.3 Actores  Primarios: Aquellos que interactúan tanto con la DB como con su información: Actores Funciones Administradores Autorizar, monitorear y coordinar Diseñadores Identificar los datos que se almacenarán y sus estructuras Desarrolladores Implementar los mecanismos de acceso Usuarios finales  Casuales  Paramétricos: Utilizan transacciones enlatadas  Sofisticados  Independientes: Operan mediante interfaces sencillas  Secundarios: Aquellos que no están interesados en el contenido de la BD: Actores Funciones Implementadores De módulos e interfaces de la DBMS Operadores de Sistemas Ejecutan las políticas definidas por los diseñadores 1.4 Modelos de datos  Modelo de datos: Colección de conceptos utilizados para describir la estructura de una BD  Categorías: Modelo Descripción Conceptual Describe la relación y características de los datos Lógico Representa las características indicadas en el Modelo Conceptual. Ejemplos: Modelo Relacional Modelo Dato-Objeto Físico Describe cómo el modelo lógico es implementado en una estructura de archivos  Arquitectura de tres esquemas: # Esquema Descripción Lenguaje Acrónimo Sigla 1 Interno Almacena la estructura física de la BD DDL Data Definition Language 2 Conceptual Describe la estructura de toda la BD y sus usuarios SDL Storage Definition Language 3 Vistas de Usuario Describe determinada parte de la BD que es de interés para determinado grupo de usuarios VDL View Definition Language 5  Mapeo: Acto de transformar y transmitir las consultas entre los esquemas de distintos niveles  Independencia de datos: Habilidad de cambiar el esquema de un nivel sin afectar al esquema del nivel superior2  DML (Data Manipulation Language): Familia de lenguajes de manipulación de BD: Categoría Descripción Procedural Incrustado en lenguajes de programación de propósito general Consulta Utilizado de forma independiente e interactiva  SQL (Simply Query Language): Lenguaje que incluye a las familias DDL, SDL, VDL y DML 1.5 DBMS  Interfaces de una DBMS: Basada en Menúes Formulario Gráficas Lenguaje Natural Entrada y Salida de Voz Usuarios Paramétricos Específicas del DBA  Módulos y Componentes:  Utilidades del DBMS: o Carga de archivos de datos o Copia de Seguridad de la BD o Organización y almacenamiento de la BD o Monitoreo de Performance 2 Sólo el mapeo se ve afectado por el cambio 6  Clasificación: Criterio Clasificación Modelo de Datos  Relacional  Dato-Objeto  Jerárquica  Legacy  Objeto-Relacional  XML-nativo Cantidad de Usuarios  Único  Multiusuario Distribución  Centralizado  Distribuido3 Tipo de Ruta de Acceso Especialización  Propósito General  Propósito Específico  OLTP (Online Transaction Process)4 3 Esta categoría, a su vez, puede clasificarse en homogéneo (utiliza el mismo SW en todas las locaciones) y heterogéneo 4 Soporte a muchas transacciones concurrentes a bajo costo de demoras 7 2. Diseño Conceptual 2.1 Normas Básicas  Diseño conceptual: Etapa en la que se construye un esquema conceptual en un lenguaje de alto nivel, definiendo el dominio del problema  Construcción: 1. Estudio de la realidad 2. Especificación en lenguaje de alto nivel 3. Validación del resultado  Componentes: Origen Componente Descripción Conceptos Conjuntos Elementos de interés que por sus características, es conveniente la agrupación Relaciones Entre conjuntos Restricciones de integridad Validan los elementos que pueden pertenecer a una relación Términos Atributo Características comunes de los elementos de un conjunto Cardinalidad De elementos de un conjunto relacionados con el origen: N:1, N:N  Totalidad: Una relación es total respecto de un conjunto, si todos sus elementos están en dicha relación  Principios: 100% Un esquema conceptual de un problema debe representar todos sus aspectos relevantes Conceptualización Un esquema conceptual no debe tener elementos de implementación 2.2 Modelo Entidad-Relación  Modelo Entidad-Relación (ER): DDL gráfico utilizado para la representación de estructura y restricciones de integridad5  Construcción: 1. Identificar elementos del problema 2. Identificar relaciones entre los elementos 3. Representar propiedades de los elementos 4. Especificar restricciones 5 Las mismas se realizan en lógica de primer orden o teoría de conjuntos 8  Constructores: Constructor Interpretación Conjunto de Entidades Atributos: Función entidad-valor6: 𝐴: 𝐶𝑜𝑛𝑗𝑢𝑛𝑡𝑜𝐸𝑙𝑒𝑚𝑒𝑛𝑡𝑜𝑠 → 𝐵𝑠 × 𝐶𝑠 𝐵: 𝐴 = 𝐵𝑠 × 𝐶𝑠 → 𝐵𝑠 Atributo Multivalorado: compuesto de muchos valores del mismo dominio Atributo Determinante: Actúa como “identificador”7, no permitiendo que dos entidades del conjunto posean el mismo valor en ese atributo8  Operadores: Operador Interpretación Relación entre dos o tres conjuntos de entidades (las relaciones triples pueden verse como la intersección de entidades en un Diagrama de Venn) Cardinalidad (en el sentido de lectura): N Cualquier cantidad x x cantidades como máximo Todo elemento debe estar en la relación Operador de “casting” que reinterpreta su contenido como un nuevo conjunto de entidades. Ejemplo: Especialización: Indica que los “hijos” son subconjuntos9 de los “padres” Entidad Débil: Para su identificación (“razón de ser”) es necesario viajar hacia la entidad fuerte. Las entidades débiles pueden o no poseer un identificador parcial (que los identifique dentro de todas las relaciones con las entidades fuertes) 6 Para cada entidad, devuelve un valor. Pueden pensarse como “tipos abstractos” 7 Estos son necesarios para cada conjunto de entidades: cada entidad debe ser identificable por un atributo determinante 8 En particular, prestar atención en las combinaciones: La combinación de B y C conforman un atributo “identificatorio” No puede repetirse ningún B independientemente de que los C sean distintos y viceversa 9 En el sentido matemático; por tanto, no se cumple si el cubrimiento del “padre” por sus “hijos”, ni que los mismos sean mutuoexcluyentes 9  Autorelaciones: Deben tener un rol en cada arco. En las restricciones se debe indicar si se desea (+) o no (-): - Ciclos - Reflexividad + Transitividad 2.3 Calidad de los Esquemas Conceptuales  Medidores de calidad: Maximizar Completitud Correctitud Minimalidad Balancear Expresividad Explicitud  Completitud: Representa todas las características del problema  Correctitud: i. Sintáctica ii. Semántica  Minimalidad: Cada elemento del problema aparece una sola vez en el esquema  Expresividad: Facilidad de comprensión utilizando semántica del modelo  Explicitud: No utiliza más formalismos que el diagrama ER 10 11 3. Modelo Relacional 3.1 Estructuras  Dominio: Conjunto de valores atómicos  Relación: Esquema 𝑅(𝐴1, … , 𝐴𝑛) R nombre de la relación 𝐴𝑖 atributo i de dominio 𝐷𝑖 Instancia 𝑟(𝑅) Conjunto10 de tuplas que cumplen con el esquema de R  Tupla: Función elemento de 𝑟(𝑅) que, dado un atributo del esquema de R, retorna su valor  Esquema Relacional (Tablas): Conjunto de esquemas de relación 3.2 Restricciones de Integridad (RI)  Restricciones de Dominio: Tipado de cada Dominio  Restricciones de Claves: Tipo Definición Superclave Subconjunto de atributos de una relación que es único para cada tupla posible Clave11 Superclave minimal Clave Foránea (FK) Atributo en una relación que es clave en otra relación (y cuyos valores se corresponden a ella)  RI: Conjunto de Restricciones de Dominio y Restricciones de Claves  Validez de una BD: Una BD es válida sii satisface todas sus RI  Operaciones de modificación: Operación Sintaxis Conflictos con RI Inserción INSERT tupla INTO R Eliminación DELETE FROM R WHERE condición Cuando haya una FK sobre R Actualización UPDATE R SET atributo1 = valor1 … atributoN = valorN WHERE condición Al intentar actualizar una clave o FK 10 Por tanto no hay elementos ni ordenados ni repetidos 11 Éstas se indican subrayando los atributos en el esquema 12 3.3 Cálculo Relacional de Tuplas: Sintaxis y Semántica  Consultas: Especificación de un conjunto de tuplas por comprensión sobre el universo de tuplas: {〈𝑡1, … , 𝑡𝑛〉 𝜑(𝑥1, … , 𝑥𝑛)⁄ } 𝑡𝑖 = {𝑥𝑖. 𝐴𝑘 con { 𝑥𝑖 variable libre de φ 𝐴𝑘 atributo de la tupla de una tabla 𝑐𝑖 constante 𝜑 fórmula de lógica de primer orden tal que 𝐹𝑉(𝜑) = {𝑥1, … , 𝑥𝑛}  Términos de construcción de 𝜑: 𝑥𝑖 variable 𝑐𝑖 constante (de algún Dominio) 𝑥𝑖. 𝐴𝑗 con 𝐴𝑗 atributo  Fórmulas de construcción de 𝜑: Fórmula Semántica 𝒕𝒊 𝒐𝒑𝒆𝒓𝒂𝒅𝒐𝒓 𝒕𝒋12 𝒕𝒂𝒃𝒍𝒂𝒋(𝒙𝒊) Verdadera sii ∃𝑥𝑖: 𝑥𝑖 ∈ 𝑡𝑎𝑏𝑙𝑎𝑗 en la BD (𝝋 𝒄𝒐𝒏𝒆𝒄𝒕𝒐𝒓𝑳ó𝒈𝒊𝒄𝒐 𝝍) Verdadera si lo es en el momento de la consulta (¬𝝋) ∃𝒙𝒊. 𝝋 Equivalente: ∃𝑡 ∈ 𝑃. 𝜑 ∃𝑡. (𝑃(𝑡) ∧ 𝜑) ∀𝒙𝒊. 𝝋 ∀𝑡 ∈ 𝑃. 𝜑 ∀𝑡. (𝑃(𝑡) → 𝜑) (∀𝑡 ∈ 𝑃 ∧ 𝑡. 𝑎 = 𝑏). 𝜑 ∀𝑡. (𝑃(𝑡) ∧ 𝑡. 𝑎 = 𝑏 → 𝜑) ∧ ∃𝑠. (𝑃(𝑠) ∧ 𝑠. 𝑎 = 𝑏) 3.4 Cálculo Relacional de Tuplas: Seguridad y Pragmática  Fórmulas inseguras: Fórmulas que podrían generar infinitos resultados  Fórmulas seguras: Una expresión es segura independientemente del dominio sii todos los alores de su resultado pertenecen al dominio de la expresión  Criterios para fórmulas seguras: ⋁ 𝜑𝑖 Todas las variables libres no negadas deben aparecer en cada 𝜑𝑖 ⋀ 𝜑𝑖 Cada variable libre debe aparecer no negada en al menos una 𝜑𝑖  Pragmática de las consultas: Se accede a las claves de un elemento y luego se relacionan a través de ellas 12 𝑜𝑝𝑒𝑟𝑎𝑑𝑜𝑟 ∈ {=, <, ≥, ≠, … } 13 3.5 Cáculo Relacional de Dominios y Equivalencias  Consultas: Especificación de un conjunto de valores de dominio por comprensión sobre el universo de todos los dominios: {𝑡1, … , 𝑡𝑛 𝜑⁄ } 𝑡𝑖 = { 𝑥𝑖 variable libre de φ 𝑐𝑖 constante 𝜑 fórmula de lógica de primer orden tal que 𝐹𝑉(𝜑) = {𝑡1, … , 𝑡𝑛}  Variables: Son atributos y se corresponden entre sí al especificar los esquemas y se utilizan en toda la estructura: se usa “_” para omitir los valores en el mismo. Ejemplo: {𝑛𝑜𝑚, 𝑑𝑖𝑟 ∃𝑛𝑓. (𝐹𝐴𝐵𝑆(𝑛𝑓, 𝑛𝑜𝑚, 𝑑𝑖𝑟) ∧ 𝑉𝐸𝑁𝑇𝐴𝑆(𝑛𝑓, _, _))⁄ }  Equivalencias: Tipo Equivalencia Cuantificador ∀𝑥. 𝑃(𝑥) ¬∃𝑥. ¬𝑃(𝑥) ∃𝑥. 𝑃(𝑥) ¬∀𝑥. ¬𝑃(𝑥) Conector lógico ¬(𝑥 ∧ 𝑦) ¬𝑥 ∨ ¬𝑦 ¬(𝑥 ∨ 𝑦) ¬𝑥 ∧ ¬𝑦 𝑥 → 𝑦 ¬𝑥 ∨ 𝑦 3.6 Álgebra Relacional  Descripción de los operadores: Los operadores retornan siempre una relación. Cada relación –y por tanto composición de operadores- conforma una expresión. Como los resultados son conjuntos, no existen tuplas repetidas  Definición de los operadores básicos: Nombre Notación Descripción Ejemplo Relación 𝑅𝑒𝑙 Expresión que retorna una copia de la relación 𝑅𝑒𝑙 𝑆𝑡𝑢𝑑𝑒𝑛𝑡 Selector 𝜎𝑐𝑜𝑛𝑑𝐸𝑥𝑝𝑟 Retorna las filas de la relación 𝐸𝑥𝑝𝑟 que cumplen la condición lógica 𝑐𝑜𝑛𝑑 𝜎 𝐺𝑃𝐴>3,5 ∧ 𝑠𝑁𝑎𝑚𝑒=′𝐹𝑢𝑙𝑎𝑛𝑜′𝑆𝑡𝑢𝑑𝑒𝑛𝑡 Proyector 𝜋𝐴𝑖1 ,…,𝐴𝑖𝑛 𝐸𝑥𝑝𝑟 Retorna las columnas de atributos 𝐴𝑖1, … , 𝐴𝑖𝑛 de la relación 𝐸𝑥𝑝𝑟13 𝜋𝑠𝐼𝐷,𝑑𝑒𝑐(𝜎𝐺𝑃𝐴>3,5𝑆𝑡𝑢𝑑𝑒𝑛𝑡) Producto Cartesiano (Cruz) 𝐸𝑥𝑝𝑟1 × 𝐸𝑥𝑝𝑟2 Retorna el producto cartesiano de ambas expresiones14 𝑆𝑡𝑢𝑑𝑒𝑛𝑡 × 𝐴𝑝𝑝𝑙𝑦 Unión 𝐸𝑥𝑝𝑟1 ∪ 𝐸𝑥𝑝𝑟2 Retorna el conjunto unión de tuplas de sus operandos (el esquema debe ser el mismo o compatible15) 𝜋𝑐𝑁𝑎𝑚𝑒𝐶𝑜𝑙𝑙𝑒𝑔𝑒 ∪ 𝜋𝑠𝑁𝑎𝑚𝑒𝑆𝑡𝑢𝑑𝑒𝑛𝑡 Diferencia 𝐸𝑥𝑝𝑟1 − 𝐸𝑥𝑝𝑟2 Retorna el conjunto diferencia de tuplas de sus operandos (el esquema debe ser el mismo o compatible) 𝜋𝑠𝐼𝐷𝑆𝑡𝑢𝑑𝑒𝑛𝑡 − 𝜋𝑠𝐼𝐷𝐴𝑝𝑝𝑙𝑦 13 Puede utilizarse posiciones de una relación mediante $posición. Se deben utilizar todas posiciones o todos nombres de atributos 14 Puede pensarse como la “unión” de las tablas que representan ambas Expresiones, donde los atributos de igual nombre son diferenciados: 𝐸𝑥𝑝𝑟1. 𝑎 ≠ 𝐸𝑥𝑝𝑟2. 𝑎 15 Por “compatible” se entiende distintos nombres de los atributos pero igual dominio 14  Definición de operadores derivados: Nombre Notación Definición Descripción Unión Natural 𝐸𝑥𝑝𝑟1 ⋈ 𝐸𝑥𝑝𝑟2 = 𝐸𝑥𝑝𝑟1 ∗ 𝐸𝑥𝑝𝑟2 𝜋𝐸𝑠𝑞𝑢𝑒𝑚𝑎(𝐸𝑥𝑝𝑟1)∪𝐸𝑠𝑞𝑢𝑒𝑚𝑎(𝐸𝑥𝑝𝑟2) (𝜎 𝐸𝑥𝑝𝑟1𝐴1=𝐸𝑥𝑝𝑟2𝐴1∧ 𝐸𝑥𝑝𝑟1𝐴2=𝐸𝑥𝑝𝑟2𝐴2∧…(𝐸𝑥𝑝𝑟1 × 𝐸𝑥𝑝𝑟2)) Une las tuplas de sus operandos cuyos atributos de igual nombre adquieran igual valor16 Unión Theta 𝐸𝑥𝑝𝑟1 ⋈𝜃 𝐸𝑥𝑝𝑟2 𝜎𝜃(𝐸𝑥𝑝𝑟1 × 𝐸𝑥𝑝𝑟2) Une sus operandos en la condición 𝜃 División 𝐸𝑥𝑝𝑟1 ÷ 𝐸𝑥𝑝𝑟2 𝜋𝑋(𝐸𝑥𝑝𝑟1) − 𝜋𝑋((𝜋𝑋(𝐸𝑥𝑝𝑟1) × 𝐸𝑥𝑝𝑟2) − 𝐸𝑥𝑝𝑟1) Primeros |𝑋| atributos de 𝐸𝑥𝑝𝑟1 cuyos restantes atributos (coincidientes con 𝐸𝑥𝑝𝑟2) incluyen todos los valores de 𝐸𝑥𝑝𝑟2 17 Intersección 𝐸𝑥𝑝𝑟1 ∩ 𝐸𝑥𝑝𝑟2 𝐸𝑥𝑝𝑟1 − (𝐸𝑥𝑝𝑟1 − 𝐸𝑥𝑝𝑟2) Si el esquema coincide: 𝐸𝑥𝑝𝑟1 ⋈ 𝐸𝑥𝑝𝑟2 Intersecta sus operandos Renombrador 𝜌𝑅𝑒𝑙(𝐴𝑖1 ,…,𝐴𝑖𝑛)(𝐸𝑥𝑝𝑟) Retorna un nuevo esquema al computar Expr creando una relación Rel de atributos 𝐴𝑖1, … , 𝐴𝑖𝑛 18 𝜌𝑐(𝑛𝑎𝑚𝑒)(𝜋𝑐𝑁𝑎𝑚𝑒𝐶𝑜𝑙𝑙𝑒𝑔𝑒) ∪ 𝜌𝑐(𝑛𝑎𝑚𝑒)(𝜋𝑠𝑁𝑎𝑚𝑒𝑆𝑡𝑢𝑑𝑒𝑛𝑡)  Propiedades de los operadores: o 𝐴 ⋈ 𝐵 = 𝐴 × 𝐵 ⟺ esquema(𝐴) ≠ esquema(𝐵) o 𝐴 × ∅ = ∅ 16 Por tanto, elimina las columnas con nombres repetidos 17 Ejemplo: 𝑄 = 𝑅 ÷ 𝑆: 𝑹(𝑨, 𝑪) 𝑺(𝑪) 𝑸(𝑪) 𝒂𝟏 𝒂𝟏 𝒂𝟐 𝒂𝟐 𝒂𝟐 𝒂𝟐 𝒂𝟑 𝒂𝟑 𝒄𝟏 𝒄𝟐 𝒄𝟏 𝒄𝟐 𝒄𝟑 𝒄𝟒 𝒄𝟏 𝒄𝟑 ÷ 𝑐1 𝑐2 𝑐3 = 𝑎2 18 Su principal utilidad es la de unificar esquemas y así poder aplicar otros operadores 15 4. Equivalencia entre MER y Modelo Relacional 4.1 Dependencias de inclusión  Dependencias de Inclusión: Dependencias del modelo relacional que especifica que: ∏ 𝐴 𝑎1,…,𝑎𝑛 ⊆ ∏ 𝐵 𝑏1,…,𝑏𝑛  Claves foráneas y dependencias de inclusión: Las claves foráneas son un caso particular de las dependencias de inclusión dado que en éstas no se exige la unicidad de aquella 4.2 Equivalencia de constructores Constructor Equivalencia ConjuntoDeEntidades(…) ConjuntoDeEntidades(…, B, C) ConjuntoDeEntidades(idConjuntoDeEntidades, …) As(idConjuntoDeEntidades, A) Restricción: ∏ 𝐴𝑠 𝑖𝑑𝐶𝑜𝑛𝑗𝑢𝑛𝑡𝑜𝐷𝑒𝐸𝑛𝑡𝑖𝑑𝑎𝑑𝑒𝑠 ⊆ ∏ 𝐶𝑜𝑛𝑗𝑢𝑛𝑡𝑜𝐷𝑒𝐸𝑛𝑡𝑖𝑑𝑎𝑑𝑒𝑠 𝑖𝑑𝐶𝑜𝑛𝑗𝑢𝑛𝑡𝑜𝐷𝑒𝐸𝑛𝑡𝑖𝑑𝑎𝑑𝑒𝑠 ConjuntoDeEntidades(A, …) 16 4.3 Equivalencia de relaciones19  Binarias: Cardinalidad (A : B) Totalidad (de B a A) Equivalencia N : N  R(idA, idB, r, …) A(idA, …) B(idB, …) Restricciones: ∏ 𝑅 𝑖𝑑𝐴 ⊆ ∏ 𝐴 𝑖𝑑𝐴 ∏ 𝑅 𝑖𝑑𝐵 ⊆ ∏ 𝐵 𝑖𝑑𝐵  Se agrega la restricción: ∏ 𝐵 𝑖𝑑𝐵 ⊆ ∏ 𝑅 𝑖𝑑𝐵 1 : N  R(idA, idB, r, …) A(idA, …) B(idB, …) Restricciones: ∏ 𝑅 𝑖𝑑𝐴 ⊆ ∏ 𝐴 𝑖𝑑𝐴 ∏ 𝑅 𝑖𝑑𝐵 ⊆ ∏ 𝐵 𝑖𝑑𝐵  A(idA, …) B(idB, idA, r, …) Restricciones: ∏ 𝐵 𝑖𝑑𝐴 ⊆ ∏ 𝐴 𝑖𝑑𝐴  Entidades débiles: Tablas: A(idA, …) B(idA, idB, r, …) Restricción: ∏ 𝐵 𝑖𝑑𝐴 ⊆ ∏ 𝐴 𝑖𝑑𝐴 19 Los atributos son tratados como en 4.2 17  Agregaciones20: Tablas: C(idC, …) R(idA, idB, r, …) Q(idA, idB, idC, q, …) Restricciones: ∏ 𝑄 𝑖𝑑𝐶 ⊆ ∏ 𝐶 𝑖𝑑𝐶 ∏ 𝑄 𝑖𝑑𝐴,𝑖𝑑𝐵 ⊆ ∏ 𝑅 𝑖𝑑𝐴,𝑖𝑑𝐵 4.4 Equivalencia de categorizaciones Restricciones Equivalencia Ninguna21 A(id, a, …) X(id, …) B(id) C(id, c, …) 𝑿 = 𝑨 ∪ 𝑩 ∪ 𝑪 A(id, a, …) 𝑋 = { 〈𝑡. 𝑖𝑑, … 〉 / 𝐴(𝑡) ∨ 𝐵(𝑡) ∨ 𝐶(𝑡) } 22 B(id) C(id, c, …) Disjuntas dos a dos X(id, …, a, c, tipo) Donde se incida en tipo a qué categoría pertenece Disjuntas (no dos a dos) X(id, …, a, c, esA, esB, esC) Donde esA, esB, esC son booleanos que identifican la agregación 20 Para otras cardinalidades se debe proceder como se indica anteriormente teniendo en cuenta que la agregación es una operación de casting 21 Es aplicable a todos los demás casos con las restricciones adecuadas 22 X se implementa como una vista 18 19 5. Diseño Relacional 5.1 Pautas de diseño Esquema Nombre Descripción Consideraciones  Clara semántica de atributos Claridad sobre qué representa una tabla y que una tupla esté en ella No combinar atributos de varios tipos de entidades y vínculos en una sola relación a b b Reducción de valores redundantes Eliminar la mayor cantidad de valores redundantes Inserción, eliminación y modificación anómalas a null b Prevención de valores nulos Evitar los valores nulos. Si no es posible, que su significado sea único Que el significado de nulos sea: “no se conoce ese dato para esa tupla”23 X(a, b, c, e) Y(c, e) Y(b, c, e) Particionamiento de tablas consistente Tuplas erróneas: los esquemas deben reunirse por condición de igualdad sobre atributos claves Sólo “dividir” las tablas sobre atributos claves 5.2 Dependencias  Dependencia Funcional (DF) y Dependencias Multivaluadas (DMV): Restricciones de integridad sobre el modelo relacional que implica que: Dada una instancia de una relación para la que X e Y son atributos y Z = R - XY: Dependencia Funcional Multivaluada Sigla DF DMV Notación 𝑋 → 𝑌 𝑋 ↠ 𝑌 Definición ∀𝑡1, 𝑡2 ∈ 𝑟, 𝑡1[𝑋] = 𝑡2[𝑋] ⇒ 𝑡1[𝑌] = 𝑡2[𝑌] ∀𝑟, si ∃𝑡1, 𝑡2: 𝑡1[𝑋] = 𝑡2[𝑋] ⟹ ∃𝑡3, 𝑡4 tales que:  𝑡1[𝑋] = 𝑡2[𝑋] = 𝑡3[𝑋] = 𝑡4[𝑋]  𝑡3[𝑌] = 𝑡1[𝑌] y 𝑡4[𝑌] = 𝑡2[𝑌]  𝑡3[𝑍] = 𝑡2[𝑍] y 𝑡4[𝑍] = 𝑡1[𝑍] Descripción X determina a Y para toda tupla de esa instancia X determina para cada Y distinto, un conjunto (el mismo y todo) de valores de Z24  DMV Embebida: Una DMV Embebida 𝑋 ↠ 𝑌 | 𝑍 indica que 𝑋 ↠ 𝑌 se cumple para todo esquema 𝑋 ∪ 𝑌 ∪ 𝑍25 23 Especial atención sobre categorizaciones 24 Z es independiente de Y y viceversa, pero se relacionan en R por la existencia de X: Por cada valor 𝑍𝑖 de 𝑋0𝑌0, si existe una tupla 𝑋0𝑌1, ésta debe estar relacionada también con 𝑍𝑖: Tupla X Y Z 𝒕𝟏 𝑥1 𝑦1 𝑧1 𝒕𝟐 𝑥1 𝑦2 𝑧2 𝒕𝟑 𝑥1 𝑦1 𝑧2 𝒕𝟒 𝑥1 𝑦2 𝑧1 25 Por tanto, durante una descomposición, éstas no deben considerarse hasta que se obtenga que algún 𝑅𝑖 = 𝑋 ∪ 𝑌 ∪ 𝑍 20  Reglas de inferencia26: Naturaleza Nombre Antecedente ⊢ Precedente Básicas (de Armstrong) Reflexiva 𝑌 ⊆ 𝑋 𝑋 → 𝑌 Aumento 𝑋 → 𝑌 𝑋𝑍 → 𝑌𝑍 Transitiva 𝑋 → 𝑌, 𝑌 → 𝑍 𝑋 → 𝑍 DF Identidad 𝑋 𝑋 → 𝑋 Descomposición 𝑋 → 𝑌𝑍 𝑋 → 𝑌 Unión 𝑋 → 𝑌, 𝑌 → 𝑍 𝑋 → 𝑌𝑍 Pseudotransitiva 𝑋 → 𝑌, 𝑊𝑌 → 𝑍 𝑊𝑋 → 𝑍 DMV Complemento 𝑋 ↠ 𝑌 𝑋 ↠ 𝑅 − 𝑋 ∪ 𝑌 Aumento 𝑋 ↠ 𝑌, 𝑊 ⊇ 𝑍 𝑊𝑋 ↠ 𝑌𝑍 Transitiva 𝑋 ↠ 𝑌, 𝑌 ↠ 𝑍 𝑋 ↠ 𝑍 − 𝑌 Pseudotransitiva 𝑋 ↠ 𝑌, 𝑊𝑌 ↠ 𝑍 𝑊𝑋 ↠ 𝑍 − 𝑊𝑌 Relacionamiento DF-DMV Réplica 𝑋 → 𝑌 𝑋 ↠ 𝑌 Combinación 𝑋 ↠ 𝑌, ∃𝑊: 𝑊 ∩ 𝑌 = ∅ 𝑊 → 𝑍 𝑌 ⊇ 𝑍 𝑋 → 𝑍  DMV Trivial: 𝑋 ↠ 𝑌 es una DMV trivial cuando cumple una de las siguientes condiciones: 𝑌 ⊂ 𝑋 𝑋 ∪ 𝑌 = 𝑅  Clausura de un conjunto de DFs: 𝐹+ es una clausura de un conjunto de DFs F sii contiene todas las DFs inferidas de F  Clausura de un conjunto de atributos bajo un conjunto de DFs: Para X conjunto de atributos y F conjunto de DFs, (𝑋)𝐹 + es la clausura de X bajo F sii contiene todos los atributos de X determinados funcionalmente utilizando las DFs de F  Algoritmo para hallar todas las (𝑋)𝐹 +27: 1. Comenzar con (𝑋)𝐹 + = 𝑋 2. Para cada 𝑌 → 𝑍 ∈ 𝐹, si 𝑌 ⊆ 𝑋+ ⟹ agregar 𝑍 a (𝑋)𝐹 +  Cubrimiento de DFs: Para F y E DFs, F cubre a E sii para cada 𝑋 → 𝑌 ∈ 𝐸 ⇒ 𝑌 ∈ (𝑋)𝐹 +  Equivalencia de DFs: E y F DFs son equivalentes entre sí sii se cumple al menos una de las siguientes condiciones: E+ = F+ Todas las DFs de E pueden inferirse de F y viceversa E cubre a F y viceversa  Conjunto de DF minimal: Fmin conjunto de DF es minimal sii: 1. Toda DF tiene un solo atributo a su derecha 2. No se pueden “achicar” los atributos de la izquierda: No es posible reemplazar 𝑋 → 𝐴 ∈ 𝐹 por 𝑌 → 𝐴 con 𝑌 ⊂ 𝑋 3. No se pueden eliminar dependencias  Cubrimiento minimal: Un cubrimiento minimal de F conjunto de DFs es un conjunto minimal Fmin equivalente a F 26 Observar que toda clave primaria define una DF 27 Observar que podrían haber más elementos que los dados por la unión de clausuras 21  Algoritmo de eliminación para encontrar Fmin: # Algoritmo Aceleración28 Descripción 1 G = F Comenzar por dependencias existentes 2 Reemplazar 𝑋 → 𝐴𝐵 … por 𝑋 → 𝐴, 𝑋 → 𝐵, … “Partir” las DF 3 Para cada 𝑋 → 𝐴 ∈ 𝐺, para cada 𝐵 ∈ 𝑋, hallar (𝑋 − 𝐵)𝐺 + Si 𝐴 ∈ (𝑋 − 𝐵)𝐺 +, reemplazar 𝑋 → 𝐴 por 𝑋 − 𝐵 → 𝐴 en 𝐺 Atributos que sean compuestos a la izquierda, y se analiza si sacando uno de ellos se infiere el mismo resultado Eliminar atributos redundantes 4 Para cada 𝑋 → 𝐴 ∈ 𝐺, hallar (𝑋)𝐺−(𝑋→𝐴) + Si 𝐴 ∈ (𝑋)𝐺−(𝑋→𝐴) + , eliminar 𝑋 → 𝐴 en 𝐺 Analizar aquellas DF cuyo atributo a la derecha esté repetido en otra DF Eliminar dependencias redundantes 5.3 Definiciones sobre Atributos y Dependencias  Definiciones sobre claves: Clave Definición Superclave 𝑆 ⊆ 𝑅 es una superclave sii ∀𝑟 instancia de R, ∄𝑡1, 𝑡2 ∈ 𝑟 tal que 𝑡1[𝑆] = 𝑡2[𝑆] Clave Una clave es una superclave minimal29 Clave candidata Cada una de las claves existentes de una relación es una clave candidata Clave primaria Clave de una relación asignada arbitrariamente entre las claves candidatas presentes Clave secundaria Claves que no son primarias Atributo primo Atributo miembro de alguna clave  Definiciones sobre dependencias: Dependencia 𝑿 → 𝒀 Definición Total DF para la que no es posible quitar 𝐴 ⊆ 𝑋 sin que deje de ser una DF30 Parcial DF no Total: ∃𝐴 ⊂ 𝑋: 𝐴 → 𝑌 Transitiva ∃𝑍 no subconjunto de clave y 𝑋 → 𝑍 y 𝑍 → 𝑌31 28 Criterio para seleccionar rápidamente las DF que deben considerarse para estudiar en cada caso 29 Esto es, si se le quita alguno de sus atributos, deja de ser una superclave 30 Los atributos del antecedente ya son “minimales” en el sentido de la existencia de la DF 31 Por tanto, puede expresarse de forma transitiva usando toras DFs. 22  Definiciones sobre descomposiciones: Descomposición D Definición D de R 𝐷 = {𝑅𝑖}𝑖=1,…,𝑚 tales que ⋃ 𝑅𝑖 𝑚 𝑖=1 = 𝑅 Proyección de F sobre Ri 32 ∏ 𝐹 𝑅𝑖 = {𝑋 → 𝑌 ∈ 𝐹+: 𝑋 ∪ 𝑌 ⊆ 𝑅𝑖} Condición de preservación de F en D ⋃ ∏ 𝐹 𝑅𝑖 𝑚 𝑖=1 = 𝐹+ D que cumple Join sin pérdida (JSP) Si 𝑖 = 233 debe cumplirse una de las siguientes condiciones34: i. (𝑅1 ∩ 𝑅2) → (𝑅1 − 𝑅2) ∈ 𝐹+ ii. (𝑅1 ∩ 𝑅2) → (𝑅2 − 𝑅1) ∈ 𝐹+ Si 𝑖 > 2: Para cada instancia r de R se cumple que 𝑚 ⋈ 𝑖 = 1 ∏ (𝑟) 𝑅𝑖 = 𝑟  Cálculo de claves: 1. Se definen tres conjuntos: # Conjunto de Atributos Propiedad 1 No determinados por nadie Nunca están a la derecha 2 No forman parte de ninguna clave Sólo están a la derecha 3 Demás atributos Están tanto a la derecha como a la izquierda 2. Se determinan todas las combinaciones de atributos de los conjuntos 1 y 3 3. Se estudia la clausura de cada elemento de 2 para ver si incluyen a todos los atributos  Test de JSP para 𝑖 > 2: 1. Crear 𝑀 ∈ ℳ|𝐷|×|{𝐴 atributo de 𝑅}| 2. Para cada fila i, si: 𝐴𝑗 ∈ 𝑅𝑖 ⟹ 𝑚𝑖𝑗 = 𝑎𝑗 valor fijo 𝐴𝑗 ∉ 𝑅𝑖 ⟹ 𝑚𝑖𝑗 = 𝑏𝑖𝑗 variable del algoritmo 3. Repetir hasta que: o No haya modificaciones en M ó o Exista una fila con todos los símbolos 𝑎 (sin importar el subíndice) Lo siguiente: Para cada 𝑋 → 𝑌 ∈ 𝐹 se “fuerza” la dependencia: En las filas donde los atributos de X coincidan Igualar los símbolos de los atributos de Y (Como los 𝑏𝑖𝑗 son variables, si un 𝑏𝑖0𝑗0 adquiere un valor 𝑎𝑘, todas sus referencias deberán hacerlo) 4. La descomposición es JSP sii existe al menos una fila con todos los símbolos a (sin importar el subíndice) 32 Dependencias de F+ donde todos los atributos que aparecen están en Ri 33 La definición si 𝑖 > 2 incluye si 𝑖 = 2, pero se discrimina en este documento porque la definición para 𝑖 = 2 presenta muchas conveniencias prácticas 34 Esto es, la intersección de los esquemas de la descomposición determina la diferencia de los esquemas en algún orden. Para las DMV, la definición es análoga reemplazando → por ↠ 23 Ejemplo: 5.4 Formas Normales  Forma Normal: Proceso de normalización permite: o Catalogar los esquemas o Construir un esquema normalizado a partir de uno no normalizado  Formas Normales: Abreviación Forma Normal Definición Descripción 1NF Primera Los dominios de los atributos incluyen sólo valores atómicos Todo diseño relacional visto en el curso lo cumple 2NF Segunda Ningún atributo no primo depende parcialmente de una clave Ningún atributo que está sólo a la derecha depende de una parte de una clave. Por tanto, se podría normalizar creando varias tablas donde esas partes de las que dependen sean las claves de los atributos que dependen de él únicamente 3NF Tercera ∀X → A ∈ R se tiene que se cumple una de las siguientes propiedades:  X superclave  A atributo primo Está en 2NF y ningún atributo no primo depende transitivamente de una clave BCNF Boyce-Codd ∀X → A ∈ R se tiene que X es una superclave Todas las DF son una superclave 4NF Cuarta ∀𝑋 → 𝑌 y 𝑋 ↠ 𝑌 no trivial, X es una superclave Está en BCNF y todas las DMV no tiriviales son una superclave 24  Ejemplos: Forma Normal Ejemplo 2NF 3NF 4NF 25  Algoritmos de descomposición de Formas Normales con JSP: Forma Normal Conserva DFs Algoritmo 3NF  1. Hallar 𝐹𝑚𝑖𝑛 2. Hacer una tabla para cada 𝑓 ∈ 𝐹𝑚𝑖𝑛 donde el lado izquierdo sea el mismo: Para cada X lado izquierdo de f Crear {𝑋 ∪ 𝐴1 ∪ … ∪ 𝐴𝑚} ∈ 𝐷 Donde 𝑋 → 𝐴𝑖 ∀𝑖 = 1, . . , 𝑚 sean las únicas f con X como miembro izquierdo 3. Colocar los atributos restantes y X en una sola tabla 4. Si ninguna tabla contiene una clave de R35: Crear una tabla adicional que contengan los atributos que forman una clave36 de R BCNF37  1. Hacer 𝐷 = {𝑅} 2. Para cada 𝑑 ∈ 𝐷 que no esté en BCNF: o Encontrar 𝑋 → 𝑌 ∈ 𝑑 que, proyectándolo, se determine que viola BCNF o Reemplazar d por los dos esquemas siguientes:  𝑑 − 𝑌  𝑋 ∪ 𝑌 4NF  Análogo a BCNF reemplazando donde diga “BCNF” por “4NF”  4NF y MER: En general, al pasar de un MER al modelo relacional, se obtendrá que éste estará en 4NF; cuando esto no sucede, existen altas probabilidades de que el MER esté mal construido  Inclusiones de las Formas Normales: 35 Para esto, se calcula si desde cada partición, la clausura cubre a 𝐹+ 36 Para ello se aplica el algoritmo de cálculo de claves 37 Para su ejecución en papel, es útil diagramarlo en forma de árbol e ir descomponiendo los d que violen BCNF. La unión de las hojas será el resultado buscado 1NF 2NF 3NF BCNF 4NF 26 27 6. Procesamiento y Optimización de Consultas 6.1 Índices  Organización física de los datos por un DBMS: Almacenan sus datos en un gran archivo o una partición dedicada, administrándolos en primera persona y utilizando los servicios más básicos del SO o incluso implementando los suyos propios38.  Índice: Estructura de índice que, dada su clave, retorna como valor un puntero a un conjunto de bloques39 que contiene los datos indizados  Tipos de índices: Relación Clasificación Dominio Abstracción Físico Bloque de disco Lógico Otros índices Orden40 Ordenados Datos ordenados No Ordenados Datos no ordenados Densidad Densos Todas las claves No Densos Algunos valores Niveles Simples Multiniveles Temporalidad Permanentes Auxiliares  Desventajas en el uso de índices: Elevado costo de mantención (para cada inserción, eliminación o actualización de las tuplas). 38 Con el objetivo de acceder lo más rápido posible a distintas secciones de los archivos almacenados 39 Este conjunto de todos los bloques conforman el archivo que representa la tabla, un índice apunta a una porción de esos bloques donde justo se encuentran los datos de interés 40 No se refiere al orden de la estructura de índices, sino de los datos indizados 28  Orden de índices: Clasificación Índice Clave Valor Ejemplo Ordenados Primario Primaria Bloque + Desplazamiento Clúster41 Atributo que no es clave primaria Bloque + Desplazamiento del primer registro42 No Ordenados Secundario Atributos ordenados Lista de bloques que contienen el valor  Bitmap: Arreglo de bits sobre los valores de un atributo o una condición: para cada posición almacena si la tupla tiene determinado valor o cumple una condición predefinida para esa estructura  Estructuras implementadoras de índices: Estructura Ventajas Desventajas Hash Inserción y recuperación por igualdad Relaciones de Orden Árboles Inserción y recuperación por igualdad y orden Ocupa más espacio en disco Bitmap Atributos numerados Pocas veces aplicable 41 De agrupamiento 42 Por tanto, para este caso debe verificarse que se encontraron todos los valores recorriendo a partir del obtenido por el índice; por este motivo, en general el valor es una lista de punteros 29  Árboles B y B+: Árbol Descripción Esquema B Nodo inicial con claves y punteros ordenados B+ Punteros a los datos sólo en las hojas, mejorando el balanceo  Comparación entre estructuras: Son comparadas utilizando la cantidad de acceso a disco teniendo en cuenta que en un acceso a disco podrían recuperarse más de un nodo de la estructura y que estos podrían buffearse en memoria 30 6.2 Proceso de Optimización  Tipos de Optimización: Tipo Plan Descripción Heurística Lógico Reduce el árbol de consultas en álgebra relacional Costos Físico A cada operación de los Planes Lógicos le asocia una o más implementaciones según las estructuras disponibles Final Evalúa los Planes Físicos según los accesos de E/S requeridos  Proceso de Optimización: # Etapa Descripción Ejemplo 1 Álgebra Relacional Se construye la consulta en Álgebra Relacional partiendo de SQL como: ∏ 𝜎𝑤ℎ𝑒𝑟𝑒(×𝑓𝑟𝑜𝑚) 𝑠𝑒𝑙𝑒𝑐𝑡 Obteniendo un árbol canónico select e.nombre, d.piso from departamentos d, empleados e where e.depto = d.nroD and e.salario > 30000 2 Planes Lógicos A partir del árbol canónico se reduce el árbol empleando: - Equivalencias de expresiones - Catálogo del a DB En cada arista se indica la cantidad de tuplas estimadas que cumplen con las condiciones de la operación de destino Catálogo de la DB: Planes Lógicos: 3 Planes Físicos Se consideran las implementaciones de 𝜎 y ⋈ para determinar los costos de cada plan Operación Implementación 𝝈 Búsqueda Lineal Búsqueda Binaria Índice ⋈ Loop anidado Loop único Sort Merge 4 Plan Final Calculados los costos de cada plan, se selecciona el de menor valor  Índices en el presente modelo teórico: En el modelo teórico que aquí se construye, asume que los índices sólo pueden ser empleados en el primer nivel de las operaciones (según el Plan Lógico) 31 6.3 Optimización por Heurísticas  Criterios: # Elemento Acción 0 En todos los casos y siempre que sea posible, deben aplicarse las Equivalencias de Expresiones a fin de minimizar las operaciones de la consulta 1 𝜎 Descomponer en 𝜎s más simples 2 𝜎 Mover lo más abajo posible 3 Mover a la izquierda las ramas con menos tuplas 4 (𝜎,×) Reemplazar por ⋈𝑐𝑜𝑛𝑑𝑖𝑐𝑖ó𝑛 5 𝜋 Mover lo más abajo posible agregando los 𝜋s necesarios43  Equivalencia de expresiones: Categoría Equivalencia Descripción/Aclaraciones 𝝈 Descomposición Conmutatividad 𝝅 𝜋𝑎𝑖(𝜋𝑎1,…𝑎𝑛𝑅) = 𝜋𝑎𝑖𝑅 Eliminación de redundancia 𝜋𝑎𝜎𝑐𝑅 = 𝜎𝑐𝜋𝑎𝑅 Conmutación con 𝜎 si éste contiene atributos de 𝜋 ⋈ 𝜎𝑐(𝑅 × 𝑄) = 𝑅 ⋈𝑐 𝑄 Equivalencia de (𝜎,×) Asociatividad de ⋈𝑐 Conmutatividad de ⋈𝑐 × 𝜎𝑐(𝑅 × 𝑄) = (𝜎𝑐𝑅) × 𝑄 Si c sólo contiene atributos de R 𝜋𝑎∪𝑏(𝑅 × 𝑄) = 𝜋𝑎𝑅 × 𝜋𝑏𝑄 Si a es de R y b es de Q ∪/∩ Reglas de conjuntos 𝜎𝑐(𝑅 ∪ 𝑄) = 𝜎𝑐𝑅 ∪ 𝜎𝑐𝑄 Análogo para ∩, − y 𝜋 en lugar de 𝜎  Ejemplo: 43 En general, no se aplica debido a la pérdida de índices y la necesidad de mantener varios atributos de proyección en los niveles inferiores porque serán utilizados en los niveles superiores 32 6.4 Optimización por Costos  Parámetros: Notación Unidad Definición Fórmula 𝒏𝑻 tuplas …de la tabla T 𝑹𝑻 bytes …de una tupla de T 𝒃𝑻 bloques …necesarios para almacenar las tuplas de T ⌈ 𝑛𝑇 𝑏𝑓𝑟𝑇 ⌉ 𝒃𝒇𝑻 tuplas …en un bloque de T ⌊𝑏𝑦𝑡𝑒𝑠 𝑑𝑒𝑙 𝑏𝑙𝑜𝑞𝑢𝑒 𝑏𝑦𝑡𝑒𝑠 𝑑𝑒 𝑙𝑎 𝑡𝑢𝑝𝑙𝑎⌋ 𝒙𝑻 niveles …de un índice de T log𝑘 𝑛𝑇 + 144 𝑽(𝑨, 𝑻) …valores distintos que tiene un atributo A sobre una tabla T 𝑛𝑇 45 𝒔𝒍(𝝈𝒄𝑻) tuplas Fracción de tuplas que cumplen c en T original 1 𝑉(𝐴, 𝑇) 46 𝒋𝒔(𝑹 ⋈𝒄 𝑺) tuplas …que deben seleccionarse respecto del producto de × 1 𝑚𝑖𝑛{𝑉(𝐴, 𝑅), 𝑉(𝐴, 𝑆)} 47 𝑻(𝝈𝒄𝑹) tuplas …que cumplen con c en T 𝑛𝑅 × 𝑠𝑙(𝜎𝑐𝑅) 𝑻(𝑹 ⋈𝒄 𝑺) tuplas …que cumplen con ⋈𝑐 𝑛𝑅 × 𝑛𝑆 × 𝑗𝑠(𝑅 ⋈𝑐 𝑆)  Estrategia de implementación de operadores: Pipelined Ejecución paralela de operadores Generación de resultados Aplicación   Son comunicados entre operadores sin grabarse a disco48 𝜋   Son comunicados entre operadores grabando resultados intermedios 𝜎 ⋈  Estimaciones de costos: Los costos son calculados para cada bloque de disco49 en las acciones de: Lectura Depende de la organización de los datos Escritura Costo de grabar todo el resultado R: ⌈ 𝑛𝑅 𝑏𝑓𝑅⌉ 44 Para un B+ con k punteros por nodo sobre clave 45 Para un atributo clave 46 Si la condición es una igualdad sobre A y se asume distribución uniforme 47 Si es 𝑅 ⋈ 𝑆 natural sobre A 48 No hay costo de lectura ya que los datos están en el buffer 49 Que por tanto pueden contener varios registros o índices 33  Implementación de operadores: Operador Estrategia Restricción Descripción Costo de lectura50 𝝈𝒄𝑹 Búsqueda Lineal …de los registros que cumplen c Caso promedio: 𝑏𝑅 2 Peor caso: 𝑏𝑅 Búsqueda Binaria Ordenación Se divide la cantidad de registro y se lee en el sentido de la ordenación log2 𝑏𝑅 + ⌈ 𝑠 𝑏𝑅⌉ − 1 Índice Primario Ordenación Se consulta el índice 𝑥 + 1 Índice de Cluster Ordenación Se consulta el índice 𝑥 + ⌈ 𝑠 𝑏𝑓𝑅⌉ Índice Hash c relación de igualdad Lectura sobre el índice 1 o 2 Índice secundario con B+ Se sigue la estructura B+ Peor caso: 𝑥 + 𝑠 𝑹 ⋈𝒄 𝑺 Loop anidado por registros Leída una tupla de R, se leen todas las tuplas de S 𝑏𝑅 + 𝑛𝑅 × 𝑏𝑆 Loop anidado por bloques Leído un bloque de R, se leen todos los bloques de S 𝑏𝑅 + ⌈ 𝑏𝑅 𝑀 − 2 ⌉ × 𝑏𝑆 51 Sort-Merge Join Ordenación en R y S Recorrer S y R en paralelo: por cada valor ordenado de R se recorren los valores de S que le correspondan según c52 (y éstos serán un conjunto ordenado de S) Costo de lectura: 𝑏𝑅 + 𝑏𝑆 Costo de ordenación: 2 × 𝑏 × (1 + log2 𝑏) Index Join (Single Loop) Índice sobre S Recorrer R accediendo por índice a S 𝑏𝑅 + (𝑛𝑅 × 𝑍) Donde Z: Índice Z Secundario 𝑥 + 𝑠𝑆 Cluster 𝑥 + ⌈ 𝑠𝑆 𝑏𝑓𝑆⌉ Primario 𝑥 + 1 Hash ℎ 50 x representa la cantidad de niveles del índice. s la cantidad de tuplas resultado de la operación 51 M indica el tamaño del buffer. Es −2 porque uno se usa para R y otro para S. El factor ⌈ 𝑏𝑅 𝑀−2⌉ indica la cantidad de bloques de S que se pueden leer a la vez 52 Y éstos serán un conjunto ordenado de S. Por ejemplo, si c fuera de igualdad, para cada registro de R se recorren los S que le sean iguales, cuando deje de cumplirlo, es a partir de allí que debe analizarse para el siguiente registro de R 34  Ejemplo: Plan Lógico Valores del Catálogo Planes Físicos Mejor plan Selección con Índice Secundario y Join con Loop Anidado por Bloques, dando como resultado, 26 + 3 = 29 operaciones 35 36 7. Control de Concurrencia y Recuperación 7.1 Transacciones e Historias  Propiedad ACID: Un proceso cumple con la propiedad ACID si cumple con las siguientes propiedades: Sigla Propiedad Descripción A Atomicidad La ejecución es considerada una unidad de trabajo C Consistencia Mantiene la consistencia de la DB I Aislamiento Su ejecución no interfiere con otra D Durabilidad Sus modificaciones son persistentes en la DB  Transacción: Procesos concurrentes que ejecutan sobre datos compartidos y cumplen la propiedad ACID  Estados de una Transacción:  Operaciones de una Transacción53: Acción Notación completa Notación compacta Leer 𝑟𝑒𝑎𝑑𝑖(𝑋) 𝑟𝑖(𝑋) Escribir 𝑤𝑟𝑖𝑡𝑒𝑖(𝑋) 𝑤𝑖(𝑋) Confirmar 𝑐𝑜𝑚𝑚𝑖𝑡𝑖 𝑐𝑖 Abortar 𝑎𝑏𝑜𝑟𝑡𝑖 𝑎𝑖  Rollback: Acción de recuperación de la DB a un estado previo a la ejecución de 𝑎𝑖 en una Transacción  Grafo de Seriabilidad: Grafo de precedencia de las Transacciones que componen una Historia. Construido como: Paso Componente54 Acción 1 𝑇𝑖 Nodo 𝑇𝑖 2 𝑤𝑖 … 𝑟𝑗 𝑇𝑖 → 𝑇𝑗 3 𝑟𝑖 … 𝑤𝑗 𝑇𝑖 → 𝑇𝑗 4 𝑤𝑖 … 𝑤𝑗 𝑇𝑖 → 𝑇𝑗 53 i representa el número de la Transacción y X el lugar de la DB sobre el que se opera. La secuencia de estas operaciones, identifica una Transacción 54 Los r y w de esta columna tienen el mismo parámetro 37  Historia: Ordenación de las operaciones de un conjunto determinado de transacciones que aparecen de forma lineal respecto de ésta55  Clasificación de Historias: Historia Definición Descripción Serializable Su Grafo de Seriabilidad es acíclico56 Recuperable Ninguna transacción confirma si no han confirmado aquellas desde las que se leyó datos previamente modificados Los commits aparecen en el orden de flujo de datos: Se satisfacen las dependencias de confirmaciones57 Evitan Abortos en Cascada Ninguna transacción lee valores escritos por otras no confirmadas Que una transacción grabe y haga un commit antes de que otra lea Estricta Ninguna transacción lee o escribe hasta que todas las que escribieron sobre el mismo ítem fueron confirmadas No hay un w ni un r si no existió sobre ese ítem modificado un c  Relaciones entre las Historias:  Transaction Manager (TM): Módulo del DBMS encargado de construir las transacciones y ordenarlas en historias serializables, recuperables y que no tengan abortos en cascada. Puede cambiar un 𝑐𝑖 por un 𝑎𝑖 7.2 Control de Concurrencia  Lock y Unlock binarios: Operación con comportamiento análogo a los semáforos de SOs cuyo dominio es una porción de la DB y su codominio la transacción en la que se ejecuta: Operación Notación completa Notación compacta Acción de bloqueo/desbloqueo sobre X Lock 𝑙𝑜𝑐𝑘𝑖(𝑋) 𝑙𝑖(𝑋) Todas las operaciones Read Lock 𝑟𝑒𝑎𝑑_𝑙𝑜𝑐𝑘𝑖(𝑋) 𝑟𝑙𝑖(𝑋) Escrituras Write Lock 𝑤𝑟𝑖𝑡𝑒_𝑙𝑜𝑐𝑘𝑖(𝑋) 𝑤𝑙𝑖(𝑋) Todas las operaciones Unlock 𝑢𝑛𝑙𝑜𝑐𝑘𝑖(𝑋) 𝑢𝑖(𝑋) Todas las operaciones 55 Esto es, se “intercalan” operaciones de todas las transacciones pero nunca se cambia el orden relativo dentro de la transacción al a que pertenecen 56 Si posee ciclos, sufre de deadlock 57 Podría pensarse como qué pasaría con transacciones que aún no confirmaron respecto de una que ya lo hizo: si el aborto de aquella impacta sobre estas, entonces, no es recuperable 38  Protocolo de Locking 2PL: Reglas de locking que garanticen la seriabilidad: Variante Descripción Características Ejemplo Básico A lo largo de una Historia, primero están todos los l (fase de expansión) y luego y luego todos los u (fase de contracción)  Fácil  Deadlock58 𝑟𝑙𝑖(𝑋) … 𝑤𝑙𝑗(𝑌)⏟ 𝐸𝑥𝑝𝑎𝑛𝑠𝑖ó𝑛 … 𝑢𝑖(𝑋) … 𝑢𝑗(𝑌)⏟ 𝐶𝑜𝑛𝑡𝑟𝑎𝑐𝑐𝑖ó𝑛 Conservador Declarar primero todos los l  No hay Deadlock  Exige declarar todo lo que se utilizará 𝑟𝑙𝑖(𝑋)𝑤𝑙𝑗(𝑌) … 𝑢𝑖(𝑋)𝑢𝑗(𝑌) Estricto No se liberan wl hasta confirmar la T  Historias Estrictas  Deadlock … 𝑤𝑙𝑖(𝑋) … 𝑐𝑖𝑢𝑖(𝑋) Riguroso No se liberan ni wl ni rl hasta confirmar la T  Fácil (respecto del Estricto)  Deadlock … 𝑟𝑙𝑖(𝑋)𝑤𝑙𝑗(𝑌) … 𝑐𝑖𝑢𝑖(𝑋)𝑢𝑗(𝑌)  TimeStamp (TS): Para cada ítem X se define un Read_TS(X) y un Write_TS(X) que informa el TS de la transacción más joven que leyó y escribió sobre él respectivamente  Control de Concurrencia basado en TS: Acción que pretende T Condición para su ejecución TS(T) Acción w(X) Nadie leyó o escribió posteriormente a T < Read_TS(X) T es reiniciado con un TS actualizado < Write_TS(X) Caso contrario Se cambia Write_TS(X) por TS(X) r(X) Nadie escribió posteriormente a T < Write_TS(X) T es reiniciado con un TS actualizado Caso contrario 𝑅𝑒𝑎𝑑_𝑇𝑆(𝑋) = 𝑚𝑎𝑥{𝑇𝑆(𝑇), 𝑅𝑒𝑎𝑑_𝑇𝑆(𝑋)}  Multiversión: Se mantienen varias versiones de cada ítem y se selecciona la adecuada para cada transacción: 𝑋 = {( 𝑋𝑖, 𝑅𝑒𝑎𝑑𝑇𝑆(𝑋𝑖), 𝑊𝑟𝑖𝑡𝑒𝑇𝑆(𝑋𝑖) )} 𝑖=1,…,𝑛  Control de Concurrencia basado en Multiversión: Acción que pretende T Condición para su ejecución TS(T) Acción w(X) Nadie leyó posteriormente a T 𝑊𝑟𝑖𝑡𝑒_𝑇𝑆(𝑋𝑖) ≤ 𝑇𝑆(𝑇) < 𝑅𝑒𝑎𝑑_𝑇𝑆(𝑋𝑖) T es reiniciado con un TS actualizado Caso contrario Se crea (𝑋𝑗, 𝑇𝑆(𝑇), 𝑇𝑆(𝑇)) r(X) Ninguna: Se utiliza la última escritura más cercana a T < Write_TS(X) T es reiniciado con un TS actualizado Caso contrario 𝑅𝑒𝑎𝑑_𝑇𝑆(𝑋) = 𝑚𝑎𝑥{𝑇𝑆(𝑇), 𝑅𝑒𝑎𝑑_𝑇𝑆(𝑋)} 7.3 Otros aspectos de Concurrencia  Granularidad: Refiere al detalle con el que se define un ítem X: tupla, registro, tabla, bloque de disco…  Granularidad y performance: Granularidad Impacto Mayor Menor concurrencia Menor Mayor overhead 58 En esta columna, esto significa “Susceptible a…” 39  Registros Fantasmas: Es un registro que, a la espera de un desbloqueo, no es insertado pese a que es de interés para la transacción bloqueante  Detección de Deadlocks: Mantener un grafo de espera que detecte la existencia de deadlocks  Solución a Deadlocks: Timeout Si una transacción espera por mucho tiempo, reiniciarla Basados en TS Estrategia Descripción Wait-Die La transacción más nueva del deadlock debe abortar y recomenzar con el mismo TS Wound-Wait La transacción más nueva del deadlock debe esperar por la más vieja  Starvation: Wait-Die y Wound-Wait evitan el problema que, generalmente, pueden originarse por malos mecanismos de “selección de víctima” (puede suceder por su reinicio indefinido) 7.4 Recuperación  Log: Registro de actividad sobre la DB  Administración de logs: Deben respaldarse frecuentemente y almacenarse en lugares distintos a la DB  Valores posibles de un ítem: Sigla Valor Valor del ítem respecto de la actualización Log de59 BFIM BeFore IMage Antes Undo AFIM AFter IMage Después Redo  Ciclo de vida de una instrucción de una transacción: Paso Descripción Esquema 1 Se hacen los cambios en un buffer de memoria  2 Se registran los cambios en el log  3 La transacción confirma  4 Se baja el log al disco  5 Se bajan los cambios al disco  59 Clasificación de un log que contiene una operación y el registro BFIM/AFIM 40  Técnicas de recuperación: Actualización Operativa Ante un abort Diferida Cada transacción trabaja en una sandbox que es enviada a disco luego del commit No debe realizarse acción alguna Inmediata La base es actualizada antes del commit Se deben deshacer las operaciones de la transacción valiéndose del log Shadow Paging60 Cada transacción mantiene en memoria un conjunto de punteros hacia los valores originales y los va cambiando a nuevas páginas de memoria a medida que surjan modificaciones Recupera el conjunto de punteros original  Write-Ahead Loggin (WAL): Protocolo que garantiza que el log con el BFIM está en el disco antes de grabar la operación en la DB  Checkpoint: Registro del log que indica que todos los buffers modificados de la DB están en disco: Paso Descripción Esquema 1 Suspender transacciones en curso  2 Bajar buffers modificados  3 Registrar checkpoint  4 Bajar log  5 Reanudar transacciones   Rollback: Se debe realizar cuando una transacción aborta. Si otras transacciones se basaron en ella para continuar, éstas también deben ser abortadas, provocando un aborto en cascada 60 Útil para DB de pequeño porte debido al overhead del sistema 41  Algoritmos de recuperación61: Algoritmo Acciones de T confirmada Acciones de T no confirmada Basado en Actualización Diferida Se reconstruye el resultado utilizando el log Se relanza al finalizar la recuperación Basada en Recuperación Inmediata Se reconstruye el resultado utilizando el log Se revierten los cambios empleando los valores anteriores en el log. Se relanza la transacción Shadow Paging Se graban los punteros modificados Se graban los punteros originales 61 Todos ellos asumen la generación de historias estrictas y serializables","libVersion":"0.3.1","langs":""}