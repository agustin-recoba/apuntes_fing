{"path":"Bases de datos/pdfs/resumen_practico.pdf","text":"Fundamentos de Bases de Datos Resumen prÃ¡ctico Diego GonzÃ¡lez 2014 diesgomo@gmail.com 2 3 1. Bases de Datos 1.1 Definiciones BÃ¡sicas ï‚· Dato: RepresentaciÃ³n simbÃ³lica que ante la inexistencia de un contexto, carece de significado ï‚· InformaciÃ³n: Datos interpretados (que poseen una semÃ¡ntica) ï‚· Sistema de InformaciÃ³n (SI): Conjunto de componentes que interactÃºan con el objetivo de almacenar, recuperar y procesar datos e informaciÃ³n con el fin de crear nueva informaciÃ³n ï‚· Base de Datos (BD): Conjunto de datos relacionados entre sÃ­ ï‚· Metadatos: Reglas que determinan si una informaciÃ³n pertenece a una BD ï‚· Sistema Manejador de Bases de Datos (DBMS): SW que administra BDs ï‚· Modelo: Lenguaje que permite describir: Aspecto Modelo Estructuras de Datos De datos Conceptual Restricciones de integridad Operaciones (sobre la estructura) 1.2 Bases de Datos ï‚· Ciclo de vida de una BD: DefiniciÃ³n ï€¢ ConstrucciÃ³n ï€¢ ManipulaciÃ³n (DiseÃ±o conceptual) (DiseÃ±o lÃ³gico) (DiseÃ±o fÃ­sico) Estructura Carga de datos iniciales ExplotaciÃ³n de datos Restricciones ï‚· Ventajas de uso de BDs: Aspecto DescripciÃ³n Ventajas DefiniciÃ³n De los datos abstractamente ï‚· CentralizaciÃ³n ï‚· AbstracciÃ³n (de programas- datos/operaciones) ï‚· MÃºltiples vistas ConstrucciÃ³n ProgramaciÃ³n de la BD ï‚· Eficiencia de consultas ï‚· Enfoque declarativo de restricciones e integridad ï‚· EstandarizaciÃ³n1 ManipulaciÃ³n ExplotaciÃ³n de la BD ï‚· Datos compartidos ï‚· Control de concurrencia ï‚· Seguridad ï‚· Tolerancia ante fallas ï‚· Persistencia de datos consistentes (incluso de objetos) 1 De modelos y lenguajes que usan la BD 4 ï‚· Uso no adecuado de BDs: Aspecto DescripciÃ³n Costo de inversiÃ³n Alto en HW, SW y capacitaciÃ³n Costo de administraciÃ³n De la BD y el DBMS Naturaleza de los datos Pocos datos o muy estables en el tiempo Performance crÃ­tica Sistemas de tiempo real No hay concurrencia ï‚· Componentes: Esquema DefiniciÃ³n de la BD. Totalmente equivalente al Modelo Conceptual Instancia Estado de la BD y sus datos en un momento determinado 1.3 Actores ï‚· Primarios: Aquellos que interactÃºan tanto con la DB como con su informaciÃ³n: Actores Funciones Administradores Autorizar, monitorear y coordinar DiseÃ±adores Identificar los datos que se almacenarÃ¡n y sus estructuras Desarrolladores Implementar los mecanismos de acceso Usuarios finales ï‚· Casuales ï‚· ParamÃ©tricos: Utilizan transacciones enlatadas ï‚· Sofisticados ï‚· Independientes: Operan mediante interfaces sencillas ï‚· Secundarios: Aquellos que no estÃ¡n interesados en el contenido de la BD: Actores Funciones Implementadores De mÃ³dulos e interfaces de la DBMS Operadores de Sistemas Ejecutan las polÃ­ticas definidas por los diseÃ±adores 1.4 Modelos de datos ï‚· Modelo de datos: ColecciÃ³n de conceptos utilizados para describir la estructura de una BD ï‚· CategorÃ­as: Modelo DescripciÃ³n Conceptual Describe la relaciÃ³n y caracterÃ­sticas de los datos LÃ³gico Representa las caracterÃ­sticas indicadas en el Modelo Conceptual. Ejemplos: Modelo Relacional Modelo Dato-Objeto FÃ­sico Describe cÃ³mo el modelo lÃ³gico es implementado en una estructura de archivos ï‚· Arquitectura de tres esquemas: # Esquema DescripciÃ³n Lenguaje AcrÃ³nimo Sigla 1 Interno Almacena la estructura fÃ­sica de la BD DDL Data Definition Language 2 Conceptual Describe la estructura de toda la BD y sus usuarios SDL Storage Definition Language 3 Vistas de Usuario Describe determinada parte de la BD que es de interÃ©s para determinado grupo de usuarios VDL View Definition Language 5 ï‚· Mapeo: Acto de transformar y transmitir las consultas entre los esquemas de distintos niveles ï‚· Independencia de datos: Habilidad de cambiar el esquema de un nivel sin afectar al esquema del nivel superior2 ï‚· DML (Data Manipulation Language): Familia de lenguajes de manipulaciÃ³n de BD: CategorÃ­a DescripciÃ³n Procedural Incrustado en lenguajes de programaciÃ³n de propÃ³sito general Consulta Utilizado de forma independiente e interactiva ï‚· SQL (Simply Query Language): Lenguaje que incluye a las familias DDL, SDL, VDL y DML 1.5 DBMS ï‚· Interfaces de una DBMS: Basada en MenÃºes Formulario GrÃ¡ficas Lenguaje Natural Entrada y Salida de Voz Usuarios ParamÃ©tricos EspecÃ­ficas del DBA ï‚· MÃ³dulos y Componentes: ï‚· Utilidades del DBMS: o Carga de archivos de datos o Copia de Seguridad de la BD o OrganizaciÃ³n y almacenamiento de la BD o Monitoreo de Performance 2 SÃ³lo el mapeo se ve afectado por el cambio 6 ï‚· ClasificaciÃ³n: Criterio ClasificaciÃ³n Modelo de Datos ï‚· Relacional ï‚· Dato-Objeto ï‚· JerÃ¡rquica ï‚· Legacy ï‚· Objeto-Relacional ï‚· XML-nativo Cantidad de Usuarios ï‚· Ãšnico ï‚· Multiusuario DistribuciÃ³n ï‚· Centralizado ï‚· Distribuido3 Tipo de Ruta de Acceso EspecializaciÃ³n ï‚· PropÃ³sito General ï‚· PropÃ³sito EspecÃ­fico ï‚· OLTP (Online Transaction Process)4 3 Esta categorÃ­a, a su vez, puede clasificarse en homogÃ©neo (utiliza el mismo SW en todas las locaciones) y heterogÃ©neo 4 Soporte a muchas transacciones concurrentes a bajo costo de demoras 7 2. DiseÃ±o Conceptual 2.1 Normas BÃ¡sicas ï‚· DiseÃ±o conceptual: Etapa en la que se construye un esquema conceptual en un lenguaje de alto nivel, definiendo el dominio del problema ï‚· ConstrucciÃ³n: 1. Estudio de la realidad 2. EspecificaciÃ³n en lenguaje de alto nivel 3. ValidaciÃ³n del resultado ï‚· Componentes: Origen Componente DescripciÃ³n Conceptos Conjuntos Elementos de interÃ©s que por sus caracterÃ­sticas, es conveniente la agrupaciÃ³n Relaciones Entre conjuntos Restricciones de integridad Validan los elementos que pueden pertenecer a una relaciÃ³n TÃ©rminos Atributo CaracterÃ­sticas comunes de los elementos de un conjunto Cardinalidad De elementos de un conjunto relacionados con el origen: N:1, N:N ï‚· Totalidad: Una relaciÃ³n es total respecto de un conjunto, si todos sus elementos estÃ¡n en dicha relaciÃ³n ï‚· Principios: 100% Un esquema conceptual de un problema debe representar todos sus aspectos relevantes ConceptualizaciÃ³n Un esquema conceptual no debe tener elementos de implementaciÃ³n 2.2 Modelo Entidad-RelaciÃ³n ï‚· Modelo Entidad-RelaciÃ³n (ER): DDL grÃ¡fico utilizado para la representaciÃ³n de estructura y restricciones de integridad5 ï‚· ConstrucciÃ³n: 1. Identificar elementos del problema 2. Identificar relaciones entre los elementos 3. Representar propiedades de los elementos 4. Especificar restricciones 5 Las mismas se realizan en lÃ³gica de primer orden o teorÃ­a de conjuntos 8 ï‚· Constructores: Constructor InterpretaciÃ³n Conjunto de Entidades Atributos: FunciÃ³n entidad-valor6: ğ´: ğ¶ğ‘œğ‘›ğ‘—ğ‘¢ğ‘›ğ‘¡ğ‘œğ¸ğ‘™ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ğ‘œğ‘  â†’ ğµğ‘  Ã— ğ¶ğ‘  ğµ: ğ´ = ğµğ‘  Ã— ğ¶ğ‘  â†’ ğµğ‘  Atributo Multivalorado: compuesto de muchos valores del mismo dominio Atributo Determinante: ActÃºa como â€œidentificadorâ€7, no permitiendo que dos entidades del conjunto posean el mismo valor en ese atributo8 ï‚· Operadores: Operador InterpretaciÃ³n RelaciÃ³n entre dos o tres conjuntos de entidades (las relaciones triples pueden verse como la intersecciÃ³n de entidades en un Diagrama de Venn) Cardinalidad (en el sentido de lectura): N Cualquier cantidad x x cantidades como mÃ¡ximo Todo elemento debe estar en la relaciÃ³n Operador de â€œcastingâ€ que reinterpreta su contenido como un nuevo conjunto de entidades. Ejemplo: EspecializaciÃ³n: Indica que los â€œhijosâ€ son subconjuntos9 de los â€œpadresâ€ Entidad DÃ©bil: Para su identificaciÃ³n (â€œrazÃ³n de serâ€) es necesario viajar hacia la entidad fuerte. Las entidades dÃ©biles pueden o no poseer un identificador parcial (que los identifique dentro de todas las relaciones con las entidades fuertes) 6 Para cada entidad, devuelve un valor. Pueden pensarse como â€œtipos abstractosâ€ 7 Estos son necesarios para cada conjunto de entidades: cada entidad debe ser identificable por un atributo determinante 8 En particular, prestar atenciÃ³n en las combinaciones: La combinaciÃ³n de B y C conforman un atributo â€œidentificatorioâ€ No puede repetirse ningÃºn B independientemente de que los C sean distintos y viceversa 9 En el sentido matemÃ¡tico; por tanto, no se cumple si el cubrimiento del â€œpadreâ€ por sus â€œhijosâ€, ni que los mismos sean mutuoexcluyentes 9 ï‚· Autorelaciones: Deben tener un rol en cada arco. En las restricciones se debe indicar si se desea (+) o no (-): - Ciclos - Reflexividad + Transitividad 2.3 Calidad de los Esquemas Conceptuales ï‚· Medidores de calidad: Maximizar Completitud Correctitud Minimalidad Balancear Expresividad Explicitud ï‚· Completitud: Representa todas las caracterÃ­sticas del problema ï‚· Correctitud: i. SintÃ¡ctica ii. SemÃ¡ntica ï‚· Minimalidad: Cada elemento del problema aparece una sola vez en el esquema ï‚· Expresividad: Facilidad de comprensiÃ³n utilizando semÃ¡ntica del modelo ï‚· Explicitud: No utiliza mÃ¡s formalismos que el diagrama ER 10 11 3. Modelo Relacional 3.1 Estructuras ï‚· Dominio: Conjunto de valores atÃ³micos ï‚· RelaciÃ³n: Esquema ğ‘…(ğ´1, â€¦ , ğ´ğ‘›) R nombre de la relaciÃ³n ğ´ğ‘– atributo i de dominio ğ·ğ‘– Instancia ğ‘Ÿ(ğ‘…) Conjunto10 de tuplas que cumplen con el esquema de R ï‚· Tupla: FunciÃ³n elemento de ğ‘Ÿ(ğ‘…) que, dado un atributo del esquema de R, retorna su valor ï‚· Esquema Relacional (Tablas): Conjunto de esquemas de relaciÃ³n 3.2 Restricciones de Integridad (RI) ï‚· Restricciones de Dominio: Tipado de cada Dominio ï‚· Restricciones de Claves: Tipo DefiniciÃ³n Superclave Subconjunto de atributos de una relaciÃ³n que es Ãºnico para cada tupla posible Clave11 Superclave minimal Clave ForÃ¡nea (FK) Atributo en una relaciÃ³n que es clave en otra relaciÃ³n (y cuyos valores se corresponden a ella) ï‚· RI: Conjunto de Restricciones de Dominio y Restricciones de Claves ï‚· Validez de una BD: Una BD es vÃ¡lida sii satisface todas sus RI ï‚· Operaciones de modificaciÃ³n: OperaciÃ³n Sintaxis Conflictos con RI InserciÃ³n INSERT tupla INTO R EliminaciÃ³n DELETE FROM R WHERE condiciÃ³n Cuando haya una FK sobre R ActualizaciÃ³n UPDATE R SET atributo1 = valor1 â€¦ atributoN = valorN WHERE condiciÃ³n Al intentar actualizar una clave o FK 10 Por tanto no hay elementos ni ordenados ni repetidos 11 Ã‰stas se indican subrayando los atributos en el esquema 12 3.3 CÃ¡lculo Relacional de Tuplas: Sintaxis y SemÃ¡ntica ï‚· Consultas: EspecificaciÃ³n de un conjunto de tuplas por comprensiÃ³n sobre el universo de tuplas: {âŒ©ğ‘¡1, â€¦ , ğ‘¡ğ‘›âŒª ğœ‘(ğ‘¥1, â€¦ , ğ‘¥ğ‘›)â„ } ğ‘¡ğ‘– = {ğ‘¥ğ‘–. ğ´ğ‘˜ con { ğ‘¥ğ‘– variable libre de Ï† ğ´ğ‘˜ atributo de la tupla de una tabla ğ‘ğ‘– constante ğœ‘ fÃ³rmula de lÃ³gica de primer orden tal que ğ¹ğ‘‰(ğœ‘) = {ğ‘¥1, â€¦ , ğ‘¥ğ‘›} ï‚· TÃ©rminos de construcciÃ³n de ğœ‘: ğ‘¥ğ‘– variable ğ‘ğ‘– constante (de algÃºn Dominio) ğ‘¥ğ‘–. ğ´ğ‘— con ğ´ğ‘— atributo ï‚· FÃ³rmulas de construcciÃ³n de ğœ‘: FÃ³rmula SemÃ¡ntica ğ’•ğ’Š ğ’ğ’‘ğ’†ğ’“ğ’‚ğ’…ğ’ğ’“ ğ’•ğ’‹12 ğ’•ğ’‚ğ’ƒğ’ğ’‚ğ’‹(ğ’™ğ’Š) Verdadera sii âˆƒğ‘¥ğ‘–: ğ‘¥ğ‘– âˆˆ ğ‘¡ğ‘ğ‘ğ‘™ğ‘ğ‘— en la BD (ğ‹ ğ’„ğ’ğ’ğ’†ğ’„ğ’•ğ’ğ’“ğ‘³Ã³ğ’ˆğ’Šğ’„ğ’ ğ) Verdadera si lo es en el momento de la consulta (Â¬ğ‹) âˆƒğ’™ğ’Š. ğ‹ Equivalente: âˆƒğ‘¡ âˆˆ ğ‘ƒ. ğœ‘ âˆƒğ‘¡. (ğ‘ƒ(ğ‘¡) âˆ§ ğœ‘) âˆ€ğ’™ğ’Š. ğ‹ âˆ€ğ‘¡ âˆˆ ğ‘ƒ. ğœ‘ âˆ€ğ‘¡. (ğ‘ƒ(ğ‘¡) â†’ ğœ‘) (âˆ€ğ‘¡ âˆˆ ğ‘ƒ âˆ§ ğ‘¡. ğ‘ = ğ‘). ğœ‘ âˆ€ğ‘¡. (ğ‘ƒ(ğ‘¡) âˆ§ ğ‘¡. ğ‘ = ğ‘ â†’ ğœ‘) âˆ§ âˆƒğ‘ . (ğ‘ƒ(ğ‘ ) âˆ§ ğ‘ . ğ‘ = ğ‘) 3.4 CÃ¡lculo Relacional de Tuplas: Seguridad y PragmÃ¡tica ï‚· FÃ³rmulas inseguras: FÃ³rmulas que podrÃ­an generar infinitos resultados ï‚· FÃ³rmulas seguras: Una expresiÃ³n es segura independientemente del dominio sii todos los alores de su resultado pertenecen al dominio de la expresiÃ³n ï‚· Criterios para fÃ³rmulas seguras: â‹ ğœ‘ğ‘– Todas las variables libres no negadas deben aparecer en cada ğœ‘ğ‘– â‹€ ğœ‘ğ‘– Cada variable libre debe aparecer no negada en al menos una ğœ‘ğ‘– ï‚· PragmÃ¡tica de las consultas: Se accede a las claves de un elemento y luego se relacionan a travÃ©s de ellas 12 ğ‘œğ‘ğ‘’ğ‘Ÿğ‘ğ‘‘ğ‘œğ‘Ÿ âˆˆ {=, <, â‰¥, â‰ , â€¦ } 13 3.5 CÃ¡culo Relacional de Dominios y Equivalencias ï‚· Consultas: EspecificaciÃ³n de un conjunto de valores de dominio por comprensiÃ³n sobre el universo de todos los dominios: {ğ‘¡1, â€¦ , ğ‘¡ğ‘› ğœ‘â„ } ğ‘¡ğ‘– = { ğ‘¥ğ‘– variable libre de Ï† ğ‘ğ‘– constante ğœ‘ fÃ³rmula de lÃ³gica de primer orden tal que ğ¹ğ‘‰(ğœ‘) = {ğ‘¡1, â€¦ , ğ‘¡ğ‘›} ï‚· Variables: Son atributos y se corresponden entre sÃ­ al especificar los esquemas y se utilizan en toda la estructura: se usa â€œ_â€ para omitir los valores en el mismo. Ejemplo: {ğ‘›ğ‘œğ‘š, ğ‘‘ğ‘–ğ‘Ÿ âˆƒğ‘›ğ‘“. (ğ¹ğ´ğµğ‘†(ğ‘›ğ‘“, ğ‘›ğ‘œğ‘š, ğ‘‘ğ‘–ğ‘Ÿ) âˆ§ ğ‘‰ğ¸ğ‘ğ‘‡ğ´ğ‘†(ğ‘›ğ‘“, _, _))â„ } ï‚· Equivalencias: Tipo Equivalencia Cuantificador âˆ€ğ‘¥. ğ‘ƒ(ğ‘¥) Â¬âˆƒğ‘¥. Â¬ğ‘ƒ(ğ‘¥) âˆƒğ‘¥. ğ‘ƒ(ğ‘¥) Â¬âˆ€ğ‘¥. Â¬ğ‘ƒ(ğ‘¥) Conector lÃ³gico Â¬(ğ‘¥ âˆ§ ğ‘¦) Â¬ğ‘¥ âˆ¨ Â¬ğ‘¦ Â¬(ğ‘¥ âˆ¨ ğ‘¦) Â¬ğ‘¥ âˆ§ Â¬ğ‘¦ ğ‘¥ â†’ ğ‘¦ Â¬ğ‘¥ âˆ¨ ğ‘¦ 3.6 Ãlgebra Relacional ï‚· DescripciÃ³n de los operadores: Los operadores retornan siempre una relaciÃ³n. Cada relaciÃ³n â€“y por tanto composiciÃ³n de operadores- conforma una expresiÃ³n. Como los resultados son conjuntos, no existen tuplas repetidas ï‚· DefiniciÃ³n de los operadores bÃ¡sicos: Nombre NotaciÃ³n DescripciÃ³n Ejemplo RelaciÃ³n ğ‘…ğ‘’ğ‘™ ExpresiÃ³n que retorna una copia de la relaciÃ³n ğ‘…ğ‘’ğ‘™ ğ‘†ğ‘¡ğ‘¢ğ‘‘ğ‘’ğ‘›ğ‘¡ Selector ğœğ‘ğ‘œğ‘›ğ‘‘ğ¸ğ‘¥ğ‘ğ‘Ÿ Retorna las filas de la relaciÃ³n ğ¸ğ‘¥ğ‘ğ‘Ÿ que cumplen la condiciÃ³n lÃ³gica ğ‘ğ‘œğ‘›ğ‘‘ ğœ ğºğ‘ƒğ´>3,5 âˆ§ ğ‘ ğ‘ğ‘ğ‘šğ‘’=â€²ğ¹ğ‘¢ğ‘™ğ‘ğ‘›ğ‘œâ€²ğ‘†ğ‘¡ğ‘¢ğ‘‘ğ‘’ğ‘›ğ‘¡ Proyector ğœ‹ğ´ğ‘–1 ,â€¦,ğ´ğ‘–ğ‘› ğ¸ğ‘¥ğ‘ğ‘Ÿ Retorna las columnas de atributos ğ´ğ‘–1, â€¦ , ğ´ğ‘–ğ‘› de la relaciÃ³n ğ¸ğ‘¥ğ‘ğ‘Ÿ13 ğœ‹ğ‘ ğ¼ğ·,ğ‘‘ğ‘’ğ‘(ğœğºğ‘ƒğ´>3,5ğ‘†ğ‘¡ğ‘¢ğ‘‘ğ‘’ğ‘›ğ‘¡) Producto Cartesiano (Cruz) ğ¸ğ‘¥ğ‘ğ‘Ÿ1 Ã— ğ¸ğ‘¥ğ‘ğ‘Ÿ2 Retorna el producto cartesiano de ambas expresiones14 ğ‘†ğ‘¡ğ‘¢ğ‘‘ğ‘’ğ‘›ğ‘¡ Ã— ğ´ğ‘ğ‘ğ‘™ğ‘¦ UniÃ³n ğ¸ğ‘¥ğ‘ğ‘Ÿ1 âˆª ğ¸ğ‘¥ğ‘ğ‘Ÿ2 Retorna el conjunto uniÃ³n de tuplas de sus operandos (el esquema debe ser el mismo o compatible15) ğœ‹ğ‘ğ‘ğ‘ğ‘šğ‘’ğ¶ğ‘œğ‘™ğ‘™ğ‘’ğ‘”ğ‘’ âˆª ğœ‹ğ‘ ğ‘ğ‘ğ‘šğ‘’ğ‘†ğ‘¡ğ‘¢ğ‘‘ğ‘’ğ‘›ğ‘¡ Diferencia ğ¸ğ‘¥ğ‘ğ‘Ÿ1 âˆ’ ğ¸ğ‘¥ğ‘ğ‘Ÿ2 Retorna el conjunto diferencia de tuplas de sus operandos (el esquema debe ser el mismo o compatible) ğœ‹ğ‘ ğ¼ğ·ğ‘†ğ‘¡ğ‘¢ğ‘‘ğ‘’ğ‘›ğ‘¡ âˆ’ ğœ‹ğ‘ ğ¼ğ·ğ´ğ‘ğ‘ğ‘™ğ‘¦ 13 Puede utilizarse posiciones de una relaciÃ³n mediante $posiciÃ³n. Se deben utilizar todas posiciones o todos nombres de atributos 14 Puede pensarse como la â€œuniÃ³nâ€ de las tablas que representan ambas Expresiones, donde los atributos de igual nombre son diferenciados: ğ¸ğ‘¥ğ‘ğ‘Ÿ1. ğ‘ â‰  ğ¸ğ‘¥ğ‘ğ‘Ÿ2. ğ‘ 15 Por â€œcompatibleâ€ se entiende distintos nombres de los atributos pero igual dominio 14 ï‚· DefiniciÃ³n de operadores derivados: Nombre NotaciÃ³n DefiniciÃ³n DescripciÃ³n UniÃ³n Natural ğ¸ğ‘¥ğ‘ğ‘Ÿ1 â‹ˆ ğ¸ğ‘¥ğ‘ğ‘Ÿ2 = ğ¸ğ‘¥ğ‘ğ‘Ÿ1 âˆ— ğ¸ğ‘¥ğ‘ğ‘Ÿ2 ğœ‹ğ¸ğ‘ ğ‘ğ‘¢ğ‘’ğ‘šğ‘(ğ¸ğ‘¥ğ‘ğ‘Ÿ1)âˆªğ¸ğ‘ ğ‘ğ‘¢ğ‘’ğ‘šğ‘(ğ¸ğ‘¥ğ‘ğ‘Ÿ2) (ğœ ğ¸ğ‘¥ğ‘ğ‘Ÿ1ğ´1=ğ¸ğ‘¥ğ‘ğ‘Ÿ2ğ´1âˆ§ ğ¸ğ‘¥ğ‘ğ‘Ÿ1ğ´2=ğ¸ğ‘¥ğ‘ğ‘Ÿ2ğ´2âˆ§â€¦(ğ¸ğ‘¥ğ‘ğ‘Ÿ1 Ã— ğ¸ğ‘¥ğ‘ğ‘Ÿ2)) Une las tuplas de sus operandos cuyos atributos de igual nombre adquieran igual valor16 UniÃ³n Theta ğ¸ğ‘¥ğ‘ğ‘Ÿ1 â‹ˆğœƒ ğ¸ğ‘¥ğ‘ğ‘Ÿ2 ğœğœƒ(ğ¸ğ‘¥ğ‘ğ‘Ÿ1 Ã— ğ¸ğ‘¥ğ‘ğ‘Ÿ2) Une sus operandos en la condiciÃ³n ğœƒ DivisiÃ³n ğ¸ğ‘¥ğ‘ğ‘Ÿ1 Ã· ğ¸ğ‘¥ğ‘ğ‘Ÿ2 ğœ‹ğ‘‹(ğ¸ğ‘¥ğ‘ğ‘Ÿ1) âˆ’ ğœ‹ğ‘‹((ğœ‹ğ‘‹(ğ¸ğ‘¥ğ‘ğ‘Ÿ1) Ã— ğ¸ğ‘¥ğ‘ğ‘Ÿ2) âˆ’ ğ¸ğ‘¥ğ‘ğ‘Ÿ1) Primeros |ğ‘‹| atributos de ğ¸ğ‘¥ğ‘ğ‘Ÿ1 cuyos restantes atributos (coincidientes con ğ¸ğ‘¥ğ‘ğ‘Ÿ2) incluyen todos los valores de ğ¸ğ‘¥ğ‘ğ‘Ÿ2 17 IntersecciÃ³n ğ¸ğ‘¥ğ‘ğ‘Ÿ1 âˆ© ğ¸ğ‘¥ğ‘ğ‘Ÿ2 ğ¸ğ‘¥ğ‘ğ‘Ÿ1 âˆ’ (ğ¸ğ‘¥ğ‘ğ‘Ÿ1 âˆ’ ğ¸ğ‘¥ğ‘ğ‘Ÿ2) Si el esquema coincide: ğ¸ğ‘¥ğ‘ğ‘Ÿ1 â‹ˆ ğ¸ğ‘¥ğ‘ğ‘Ÿ2 Intersecta sus operandos Renombrador ğœŒğ‘…ğ‘’ğ‘™(ğ´ğ‘–1 ,â€¦,ğ´ğ‘–ğ‘›)(ğ¸ğ‘¥ğ‘ğ‘Ÿ) Retorna un nuevo esquema al computar Expr creando una relaciÃ³n Rel de atributos ğ´ğ‘–1, â€¦ , ğ´ğ‘–ğ‘› 18 ğœŒğ‘(ğ‘›ğ‘ğ‘šğ‘’)(ğœ‹ğ‘ğ‘ğ‘ğ‘šğ‘’ğ¶ğ‘œğ‘™ğ‘™ğ‘’ğ‘”ğ‘’) âˆª ğœŒğ‘(ğ‘›ğ‘ğ‘šğ‘’)(ğœ‹ğ‘ ğ‘ğ‘ğ‘šğ‘’ğ‘†ğ‘¡ğ‘¢ğ‘‘ğ‘’ğ‘›ğ‘¡) ï‚· Propiedades de los operadores: o ğ´ â‹ˆ ğµ = ğ´ Ã— ğµ âŸº esquema(ğ´) â‰  esquema(ğµ) o ğ´ Ã— âˆ… = âˆ… 16 Por tanto, elimina las columnas con nombres repetidos 17 Ejemplo: ğ‘„ = ğ‘… Ã· ğ‘†: ğ‘¹(ğ‘¨, ğ‘ª) ğ‘º(ğ‘ª) ğ‘¸(ğ‘ª) ğ’‚ğŸ ğ’‚ğŸ ğ’‚ğŸ ğ’‚ğŸ ğ’‚ğŸ ğ’‚ğŸ ğ’‚ğŸ‘ ğ’‚ğŸ‘ ğ’„ğŸ ğ’„ğŸ ğ’„ğŸ ğ’„ğŸ ğ’„ğŸ‘ ğ’„ğŸ’ ğ’„ğŸ ğ’„ğŸ‘ Ã· ğ‘1 ğ‘2 ğ‘3 = ğ‘2 18 Su principal utilidad es la de unificar esquemas y asÃ­ poder aplicar otros operadores 15 4. Equivalencia entre MER y Modelo Relacional 4.1 Dependencias de inclusiÃ³n ï‚· Dependencias de InclusiÃ³n: Dependencias del modelo relacional que especifica que: âˆ ğ´ ğ‘1,â€¦,ğ‘ğ‘› âŠ† âˆ ğµ ğ‘1,â€¦,ğ‘ğ‘› ï‚· Claves forÃ¡neas y dependencias de inclusiÃ³n: Las claves forÃ¡neas son un caso particular de las dependencias de inclusiÃ³n dado que en Ã©stas no se exige la unicidad de aquella 4.2 Equivalencia de constructores Constructor Equivalencia ConjuntoDeEntidades(â€¦) ConjuntoDeEntidades(â€¦, B, C) ConjuntoDeEntidades(idConjuntoDeEntidades, â€¦) As(idConjuntoDeEntidades, A) RestricciÃ³n: âˆ ğ´ğ‘  ğ‘–ğ‘‘ğ¶ğ‘œğ‘›ğ‘—ğ‘¢ğ‘›ğ‘¡ğ‘œğ·ğ‘’ğ¸ğ‘›ğ‘¡ğ‘–ğ‘‘ğ‘ğ‘‘ğ‘’ğ‘  âŠ† âˆ ğ¶ğ‘œğ‘›ğ‘—ğ‘¢ğ‘›ğ‘¡ğ‘œğ·ğ‘’ğ¸ğ‘›ğ‘¡ğ‘–ğ‘‘ğ‘ğ‘‘ğ‘’ğ‘  ğ‘–ğ‘‘ğ¶ğ‘œğ‘›ğ‘—ğ‘¢ğ‘›ğ‘¡ğ‘œğ·ğ‘’ğ¸ğ‘›ğ‘¡ğ‘–ğ‘‘ğ‘ğ‘‘ğ‘’ğ‘  ConjuntoDeEntidades(A, â€¦) 16 4.3 Equivalencia de relaciones19 ï‚· Binarias: Cardinalidad (A : B) Totalidad (de B a A) Equivalencia N : N ï R(idA, idB, r, â€¦) A(idA, â€¦) B(idB, â€¦) Restricciones: âˆ ğ‘… ğ‘–ğ‘‘ğ´ âŠ† âˆ ğ´ ğ‘–ğ‘‘ğ´ âˆ ğ‘… ğ‘–ğ‘‘ğµ âŠ† âˆ ğµ ğ‘–ğ‘‘ğµ ï Se agrega la restricciÃ³n: âˆ ğµ ğ‘–ğ‘‘ğµ âŠ† âˆ ğ‘… ğ‘–ğ‘‘ğµ 1 : N ï R(idA, idB, r, â€¦) A(idA, â€¦) B(idB, â€¦) Restricciones: âˆ ğ‘… ğ‘–ğ‘‘ğ´ âŠ† âˆ ğ´ ğ‘–ğ‘‘ğ´ âˆ ğ‘… ğ‘–ğ‘‘ğµ âŠ† âˆ ğµ ğ‘–ğ‘‘ğµ ï A(idA, â€¦) B(idB, idA, r, â€¦) Restricciones: âˆ ğµ ğ‘–ğ‘‘ğ´ âŠ† âˆ ğ´ ğ‘–ğ‘‘ğ´ ï‚· Entidades dÃ©biles: Tablas: A(idA, â€¦) B(idA, idB, r, â€¦) RestricciÃ³n: âˆ ğµ ğ‘–ğ‘‘ğ´ âŠ† âˆ ğ´ ğ‘–ğ‘‘ğ´ 19 Los atributos son tratados como en 4.2 17 ï‚· Agregaciones20: Tablas: C(idC, â€¦) R(idA, idB, r, â€¦) Q(idA, idB, idC, q, â€¦) Restricciones: âˆ ğ‘„ ğ‘–ğ‘‘ğ¶ âŠ† âˆ ğ¶ ğ‘–ğ‘‘ğ¶ âˆ ğ‘„ ğ‘–ğ‘‘ğ´,ğ‘–ğ‘‘ğµ âŠ† âˆ ğ‘… ğ‘–ğ‘‘ğ´,ğ‘–ğ‘‘ğµ 4.4 Equivalencia de categorizaciones Restricciones Equivalencia Ninguna21 A(id, a, â€¦) X(id, â€¦) B(id) C(id, c, â€¦) ğ‘¿ = ğ‘¨ âˆª ğ‘© âˆª ğ‘ª A(id, a, â€¦) ğ‘‹ = { âŒ©ğ‘¡. ğ‘–ğ‘‘, â€¦ âŒª / ğ´(ğ‘¡) âˆ¨ ğµ(ğ‘¡) âˆ¨ ğ¶(ğ‘¡) } 22 B(id) C(id, c, â€¦) Disjuntas dos a dos X(id, â€¦, a, c, tipo) Donde se incida en tipo a quÃ© categorÃ­a pertenece Disjuntas (no dos a dos) X(id, â€¦, a, c, esA, esB, esC) Donde esA, esB, esC son booleanos que identifican la agregaciÃ³n 20 Para otras cardinalidades se debe proceder como se indica anteriormente teniendo en cuenta que la agregaciÃ³n es una operaciÃ³n de casting 21 Es aplicable a todos los demÃ¡s casos con las restricciones adecuadas 22 X se implementa como una vista 18 19 5. DiseÃ±o Relacional 5.1 Pautas de diseÃ±o Esquema Nombre DescripciÃ³n Consideraciones ï€±ï Clara semÃ¡ntica de atributos Claridad sobre quÃ© representa una tabla y que una tupla estÃ© en ella No combinar atributos de varios tipos de entidades y vÃ­nculos en una sola relaciÃ³n a b b ReducciÃ³n de valores redundantes Eliminar la mayor cantidad de valores redundantes InserciÃ³n, eliminaciÃ³n y modificaciÃ³n anÃ³malas a null b PrevenciÃ³n de valores nulos Evitar los valores nulos. Si no es posible, que su significado sea Ãºnico Que el significado de nulos sea: â€œno se conoce ese dato para esa tuplaâ€23 X(a, b, c, e) Y(c, e) Y(b, c, e) Particionamiento de tablas consistente Tuplas errÃ³neas: los esquemas deben reunirse por condiciÃ³n de igualdad sobre atributos claves SÃ³lo â€œdividirâ€ las tablas sobre atributos claves 5.2 Dependencias ï‚· Dependencia Funcional (DF) y Dependencias Multivaluadas (DMV): Restricciones de integridad sobre el modelo relacional que implica que: Dada una instancia de una relaciÃ³n para la que X e Y son atributos y Z = R - XY: Dependencia Funcional Multivaluada Sigla DF DMV NotaciÃ³n ğ‘‹ â†’ ğ‘Œ ğ‘‹ â†  ğ‘Œ DefiniciÃ³n âˆ€ğ‘¡1, ğ‘¡2 âˆˆ ğ‘Ÿ, ğ‘¡1[ğ‘‹] = ğ‘¡2[ğ‘‹] â‡’ ğ‘¡1[ğ‘Œ] = ğ‘¡2[ğ‘Œ] âˆ€ğ‘Ÿ, si âˆƒğ‘¡1, ğ‘¡2: ğ‘¡1[ğ‘‹] = ğ‘¡2[ğ‘‹] âŸ¹ âˆƒğ‘¡3, ğ‘¡4 tales que: ï‚· ğ‘¡1[ğ‘‹] = ğ‘¡2[ğ‘‹] = ğ‘¡3[ğ‘‹] = ğ‘¡4[ğ‘‹] ï‚· ğ‘¡3[ğ‘Œ] = ğ‘¡1[ğ‘Œ] y ğ‘¡4[ğ‘Œ] = ğ‘¡2[ğ‘Œ] ï‚· ğ‘¡3[ğ‘] = ğ‘¡2[ğ‘] y ğ‘¡4[ğ‘] = ğ‘¡1[ğ‘] DescripciÃ³n X determina a Y para toda tupla de esa instancia X determina para cada Y distinto, un conjunto (el mismo y todo) de valores de Z24 ï‚· DMV Embebida: Una DMV Embebida ğ‘‹ â†  ğ‘Œ | ğ‘ indica que ğ‘‹ â†  ğ‘Œ se cumple para todo esquema ğ‘‹ âˆª ğ‘Œ âˆª ğ‘25 23 Especial atenciÃ³n sobre categorizaciones 24 Z es independiente de Y y viceversa, pero se relacionan en R por la existencia de X: Por cada valor ğ‘ğ‘– de ğ‘‹0ğ‘Œ0, si existe una tupla ğ‘‹0ğ‘Œ1, Ã©sta debe estar relacionada tambiÃ©n con ğ‘ğ‘–: Tupla X Y Z ğ’•ğŸ ğ‘¥1 ğ‘¦1 ğ‘§1 ğ’•ğŸ ğ‘¥1 ğ‘¦2 ğ‘§2 ğ’•ğŸ‘ ğ‘¥1 ğ‘¦1 ğ‘§2 ğ’•ğŸ’ ğ‘¥1 ğ‘¦2 ğ‘§1 25 Por tanto, durante una descomposiciÃ³n, Ã©stas no deben considerarse hasta que se obtenga que algÃºn ğ‘…ğ‘– = ğ‘‹ âˆª ğ‘Œ âˆª ğ‘ 20 ï‚· Reglas de inferencia26: Naturaleza Nombre Antecedente âŠ¢ Precedente BÃ¡sicas (de Armstrong) Reflexiva ğ‘Œ âŠ† ğ‘‹ ğ‘‹ â†’ ğ‘Œ Aumento ğ‘‹ â†’ ğ‘Œ ğ‘‹ğ‘ â†’ ğ‘Œğ‘ Transitiva ğ‘‹ â†’ ğ‘Œ, ğ‘Œ â†’ ğ‘ ğ‘‹ â†’ ğ‘ DF Identidad ğ‘‹ ğ‘‹ â†’ ğ‘‹ DescomposiciÃ³n ğ‘‹ â†’ ğ‘Œğ‘ ğ‘‹ â†’ ğ‘Œ UniÃ³n ğ‘‹ â†’ ğ‘Œ, ğ‘Œ â†’ ğ‘ ğ‘‹ â†’ ğ‘Œğ‘ Pseudotransitiva ğ‘‹ â†’ ğ‘Œ, ğ‘Šğ‘Œ â†’ ğ‘ ğ‘Šğ‘‹ â†’ ğ‘ DMV Complemento ğ‘‹ â†  ğ‘Œ ğ‘‹ â†  ğ‘… âˆ’ ğ‘‹ âˆª ğ‘Œ Aumento ğ‘‹ â†  ğ‘Œ, ğ‘Š âŠ‡ ğ‘ ğ‘Šğ‘‹ â†  ğ‘Œğ‘ Transitiva ğ‘‹ â†  ğ‘Œ, ğ‘Œ â†  ğ‘ ğ‘‹ â†  ğ‘ âˆ’ ğ‘Œ Pseudotransitiva ğ‘‹ â†  ğ‘Œ, ğ‘Šğ‘Œ â†  ğ‘ ğ‘Šğ‘‹ â†  ğ‘ âˆ’ ğ‘Šğ‘Œ Relacionamiento DF-DMV RÃ©plica ğ‘‹ â†’ ğ‘Œ ğ‘‹ â†  ğ‘Œ CombinaciÃ³n ğ‘‹ â†  ğ‘Œ, âˆƒğ‘Š: ğ‘Š âˆ© ğ‘Œ = âˆ… ğ‘Š â†’ ğ‘ ğ‘Œ âŠ‡ ğ‘ ğ‘‹ â†’ ğ‘ ï‚· DMV Trivial: ğ‘‹ â†  ğ‘Œ es una DMV trivial cuando cumple una de las siguientes condiciones: ğ‘Œ âŠ‚ ğ‘‹ ğ‘‹ âˆª ğ‘Œ = ğ‘… ï‚· Clausura de un conjunto de DFs: ğ¹+ es una clausura de un conjunto de DFs F sii contiene todas las DFs inferidas de F ï‚· Clausura de un conjunto de atributos bajo un conjunto de DFs: Para X conjunto de atributos y F conjunto de DFs, (ğ‘‹)ğ¹ + es la clausura de X bajo F sii contiene todos los atributos de X determinados funcionalmente utilizando las DFs de F ï‚· Algoritmo para hallar todas las (ğ‘‹)ğ¹ +27: 1. Comenzar con (ğ‘‹)ğ¹ + = ğ‘‹ 2. Para cada ğ‘Œ â†’ ğ‘ âˆˆ ğ¹, si ğ‘Œ âŠ† ğ‘‹+ âŸ¹ agregar ğ‘ a (ğ‘‹)ğ¹ + ï‚· Cubrimiento de DFs: Para F y E DFs, F cubre a E sii para cada ğ‘‹ â†’ ğ‘Œ âˆˆ ğ¸ â‡’ ğ‘Œ âˆˆ (ğ‘‹)ğ¹ + ï‚· Equivalencia de DFs: E y F DFs son equivalentes entre sÃ­ sii se cumple al menos una de las siguientes condiciones: E+ = F+ Todas las DFs de E pueden inferirse de F y viceversa E cubre a F y viceversa ï‚· Conjunto de DF minimal: Fmin conjunto de DF es minimal sii: 1. Toda DF tiene un solo atributo a su derecha 2. No se pueden â€œachicarâ€ los atributos de la izquierda: No es posible reemplazar ğ‘‹ â†’ ğ´ âˆˆ ğ¹ por ğ‘Œ â†’ ğ´ con ğ‘Œ âŠ‚ ğ‘‹ 3. No se pueden eliminar dependencias ï‚· Cubrimiento minimal: Un cubrimiento minimal de F conjunto de DFs es un conjunto minimal Fmin equivalente a F 26 Observar que toda clave primaria define una DF 27 Observar que podrÃ­an haber mÃ¡s elementos que los dados por la uniÃ³n de clausuras 21 ï‚· Algoritmo de eliminaciÃ³n para encontrar Fmin: # Algoritmo AceleraciÃ³n28 DescripciÃ³n 1 G = F Comenzar por dependencias existentes 2 Reemplazar ğ‘‹ â†’ ğ´ğµ â€¦ por ğ‘‹ â†’ ğ´, ğ‘‹ â†’ ğµ, â€¦ â€œPartirâ€ las DF 3 Para cada ğ‘‹ â†’ ğ´ âˆˆ ğº, para cada ğµ âˆˆ ğ‘‹, hallar (ğ‘‹ âˆ’ ğµ)ğº + Si ğ´ âˆˆ (ğ‘‹ âˆ’ ğµ)ğº +, reemplazar ğ‘‹ â†’ ğ´ por ğ‘‹ âˆ’ ğµ â†’ ğ´ en ğº Atributos que sean compuestos a la izquierda, y se analiza si sacando uno de ellos se infiere el mismo resultado Eliminar atributos redundantes 4 Para cada ğ‘‹ â†’ ğ´ âˆˆ ğº, hallar (ğ‘‹)ğºâˆ’(ğ‘‹â†’ğ´) + Si ğ´ âˆˆ (ğ‘‹)ğºâˆ’(ğ‘‹â†’ğ´) + , eliminar ğ‘‹ â†’ ğ´ en ğº Analizar aquellas DF cuyo atributo a la derecha estÃ© repetido en otra DF Eliminar dependencias redundantes 5.3 Definiciones sobre Atributos y Dependencias ï‚· Definiciones sobre claves: Clave DefiniciÃ³n Superclave ğ‘† âŠ† ğ‘… es una superclave sii âˆ€ğ‘Ÿ instancia de R, âˆ„ğ‘¡1, ğ‘¡2 âˆˆ ğ‘Ÿ tal que ğ‘¡1[ğ‘†] = ğ‘¡2[ğ‘†] Clave Una clave es una superclave minimal29 Clave candidata Cada una de las claves existentes de una relaciÃ³n es una clave candidata Clave primaria Clave de una relaciÃ³n asignada arbitrariamente entre las claves candidatas presentes Clave secundaria Claves que no son primarias Atributo primo Atributo miembro de alguna clave ï‚· Definiciones sobre dependencias: Dependencia ğ‘¿ â†’ ğ’€ DefiniciÃ³n Total DF para la que no es posible quitar ğ´ âŠ† ğ‘‹ sin que deje de ser una DF30 Parcial DF no Total: âˆƒğ´ âŠ‚ ğ‘‹: ğ´ â†’ ğ‘Œ Transitiva âˆƒğ‘ no subconjunto de clave y ğ‘‹ â†’ ğ‘ y ğ‘ â†’ ğ‘Œ31 28 Criterio para seleccionar rÃ¡pidamente las DF que deben considerarse para estudiar en cada caso 29 Esto es, si se le quita alguno de sus atributos, deja de ser una superclave 30 Los atributos del antecedente ya son â€œminimalesâ€ en el sentido de la existencia de la DF 31 Por tanto, puede expresarse de forma transitiva usando toras DFs. 22 ï‚· Definiciones sobre descomposiciones: DescomposiciÃ³n D DefiniciÃ³n D de R ğ· = {ğ‘…ğ‘–}ğ‘–=1,â€¦,ğ‘š tales que â‹ƒ ğ‘…ğ‘– ğ‘š ğ‘–=1 = ğ‘… ProyecciÃ³n de F sobre Ri 32 âˆ ğ¹ ğ‘…ğ‘– = {ğ‘‹ â†’ ğ‘Œ âˆˆ ğ¹+: ğ‘‹ âˆª ğ‘Œ âŠ† ğ‘…ğ‘–} CondiciÃ³n de preservaciÃ³n de F en D â‹ƒ âˆ ğ¹ ğ‘…ğ‘– ğ‘š ğ‘–=1 = ğ¹+ D que cumple Join sin pÃ©rdida (JSP) Si ğ‘– = 233 debe cumplirse una de las siguientes condiciones34: i. (ğ‘…1 âˆ© ğ‘…2) â†’ (ğ‘…1 âˆ’ ğ‘…2) âˆˆ ğ¹+ ii. (ğ‘…1 âˆ© ğ‘…2) â†’ (ğ‘…2 âˆ’ ğ‘…1) âˆˆ ğ¹+ Si ğ‘– > 2: Para cada instancia r de R se cumple que ğ‘š â‹ˆ ğ‘– = 1 âˆ (ğ‘Ÿ) ğ‘…ğ‘– = ğ‘Ÿ ï‚· CÃ¡lculo de claves: 1. Se definen tres conjuntos: # Conjunto de Atributos Propiedad 1 No determinados por nadie Nunca estÃ¡n a la derecha 2 No forman parte de ninguna clave SÃ³lo estÃ¡n a la derecha 3 DemÃ¡s atributos EstÃ¡n tanto a la derecha como a la izquierda 2. Se determinan todas las combinaciones de atributos de los conjuntos 1 y 3 3. Se estudia la clausura de cada elemento de 2 para ver si incluyen a todos los atributos ï‚· Test de JSP para ğ‘– > 2: 1. Crear ğ‘€ âˆˆ â„³|ğ·|Ã—|{ğ´ atributo de ğ‘…}| 2. Para cada fila i, si: ğ´ğ‘— âˆˆ ğ‘…ğ‘– âŸ¹ ğ‘šğ‘–ğ‘— = ğ‘ğ‘— valor fijo ğ´ğ‘— âˆ‰ ğ‘…ğ‘– âŸ¹ ğ‘šğ‘–ğ‘— = ğ‘ğ‘–ğ‘— variable del algoritmo 3. Repetir hasta que: o No haya modificaciones en M Ã³ o Exista una fila con todos los sÃ­mbolos ğ‘ (sin importar el subÃ­ndice) Lo siguiente: Para cada ğ‘‹ â†’ ğ‘Œ âˆˆ ğ¹ se â€œfuerzaâ€ la dependencia: En las filas donde los atributos de X coincidan Igualar los sÃ­mbolos de los atributos de Y (Como los ğ‘ğ‘–ğ‘— son variables, si un ğ‘ğ‘–0ğ‘—0 adquiere un valor ğ‘ğ‘˜, todas sus referencias deberÃ¡n hacerlo) 4. La descomposiciÃ³n es JSP sii existe al menos una fila con todos los sÃ­mbolos a (sin importar el subÃ­ndice) 32 Dependencias de F+ donde todos los atributos que aparecen estÃ¡n en Ri 33 La definiciÃ³n si ğ‘– > 2 incluye si ğ‘– = 2, pero se discrimina en este documento porque la definiciÃ³n para ğ‘– = 2 presenta muchas conveniencias prÃ¡cticas 34 Esto es, la intersecciÃ³n de los esquemas de la descomposiciÃ³n determina la diferencia de los esquemas en algÃºn orden. Para las DMV, la definiciÃ³n es anÃ¡loga reemplazando â†’ por â†  23 Ejemplo: 5.4 Formas Normales ï‚· Forma Normal: Proceso de normalizaciÃ³n permite: o Catalogar los esquemas o Construir un esquema normalizado a partir de uno no normalizado ï‚· Formas Normales: AbreviaciÃ³n Forma Normal DefiniciÃ³n DescripciÃ³n 1NF Primera Los dominios de los atributos incluyen sÃ³lo valores atÃ³micos Todo diseÃ±o relacional visto en el curso lo cumple 2NF Segunda NingÃºn atributo no primo depende parcialmente de una clave NingÃºn atributo que estÃ¡ sÃ³lo a la derecha depende de una parte de una clave. Por tanto, se podrÃ­a normalizar creando varias tablas donde esas partes de las que dependen sean las claves de los atributos que dependen de Ã©l Ãºnicamente 3NF Tercera âˆ€X â†’ A âˆˆ R se tiene que se cumple una de las siguientes propiedades: ï‚· X superclave ï‚· A atributo primo EstÃ¡ en 2NF y ningÃºn atributo no primo depende transitivamente de una clave BCNF Boyce-Codd âˆ€X â†’ A âˆˆ R se tiene que X es una superclave Todas las DF son una superclave 4NF Cuarta âˆ€ğ‘‹ â†’ ğ‘Œ y ğ‘‹ â†  ğ‘Œ no trivial, X es una superclave EstÃ¡ en BCNF y todas las DMV no tiriviales son una superclave 24 ï‚· Ejemplos: Forma Normal Ejemplo 2NF 3NF 4NF 25 ï‚· Algoritmos de descomposiciÃ³n de Formas Normales con JSP: Forma Normal Conserva DFs Algoritmo 3NF ï 1. Hallar ğ¹ğ‘šğ‘–ğ‘› 2. Hacer una tabla para cada ğ‘“ âˆˆ ğ¹ğ‘šğ‘–ğ‘› donde el lado izquierdo sea el mismo: Para cada X lado izquierdo de f Crear {ğ‘‹ âˆª ğ´1 âˆª â€¦ âˆª ğ´ğ‘š} âˆˆ ğ· Donde ğ‘‹ â†’ ğ´ğ‘– âˆ€ğ‘– = 1, . . , ğ‘š sean las Ãºnicas f con X como miembro izquierdo 3. Colocar los atributos restantes y X en una sola tabla 4. Si ninguna tabla contiene una clave de R35: Crear una tabla adicional que contengan los atributos que forman una clave36 de R BCNF37 ï 1. Hacer ğ· = {ğ‘…} 2. Para cada ğ‘‘ âˆˆ ğ· que no estÃ© en BCNF: o Encontrar ğ‘‹ â†’ ğ‘Œ âˆˆ ğ‘‘ que, proyectÃ¡ndolo, se determine que viola BCNF o Reemplazar d por los dos esquemas siguientes: ï‚§ ğ‘‘ âˆ’ ğ‘Œ ï‚§ ğ‘‹ âˆª ğ‘Œ 4NF ï AnÃ¡logo a BCNF reemplazando donde diga â€œBCNFâ€ por â€œ4NFâ€ ï‚· 4NF y MER: En general, al pasar de un MER al modelo relacional, se obtendrÃ¡ que Ã©ste estarÃ¡ en 4NF; cuando esto no sucede, existen altas probabilidades de que el MER estÃ© mal construido ï‚· Inclusiones de las Formas Normales: 35 Para esto, se calcula si desde cada particiÃ³n, la clausura cubre a ğ¹+ 36 Para ello se aplica el algoritmo de cÃ¡lculo de claves 37 Para su ejecuciÃ³n en papel, es Ãºtil diagramarlo en forma de Ã¡rbol e ir descomponiendo los d que violen BCNF. La uniÃ³n de las hojas serÃ¡ el resultado buscado 1NF 2NF 3NF BCNF 4NF 26 27 6. Procesamiento y OptimizaciÃ³n de Consultas 6.1 Ãndices ï‚· OrganizaciÃ³n fÃ­sica de los datos por un DBMS: Almacenan sus datos en un gran archivo o una particiÃ³n dedicada, administrÃ¡ndolos en primera persona y utilizando los servicios mÃ¡s bÃ¡sicos del SO o incluso implementando los suyos propios38. ï‚· Ãndice: Estructura de Ã­ndice que, dada su clave, retorna como valor un puntero a un conjunto de bloques39 que contiene los datos indizados ï‚· Tipos de Ã­ndices: RelaciÃ³n ClasificaciÃ³n Dominio AbstracciÃ³n FÃ­sico Bloque de disco LÃ³gico Otros Ã­ndices Orden40 Ordenados Datos ordenados No Ordenados Datos no ordenados Densidad Densos Todas las claves No Densos Algunos valores Niveles Simples Multiniveles Temporalidad Permanentes Auxiliares ï‚· Desventajas en el uso de Ã­ndices: Elevado costo de mantenciÃ³n (para cada inserciÃ³n, eliminaciÃ³n o actualizaciÃ³n de las tuplas). 38 Con el objetivo de acceder lo mÃ¡s rÃ¡pido posible a distintas secciones de los archivos almacenados 39 Este conjunto de todos los bloques conforman el archivo que representa la tabla, un Ã­ndice apunta a una porciÃ³n de esos bloques donde justo se encuentran los datos de interÃ©s 40 No se refiere al orden de la estructura de Ã­ndices, sino de los datos indizados 28 ï‚· Orden de Ã­ndices: ClasificaciÃ³n Ãndice Clave Valor Ejemplo Ordenados Primario Primaria Bloque + Desplazamiento ClÃºster41 Atributo que no es clave primaria Bloque + Desplazamiento del primer registro42 No Ordenados Secundario Atributos ordenados Lista de bloques que contienen el valor ï‚· Bitmap: Arreglo de bits sobre los valores de un atributo o una condiciÃ³n: para cada posiciÃ³n almacena si la tupla tiene determinado valor o cumple una condiciÃ³n predefinida para esa estructura ï‚· Estructuras implementadoras de Ã­ndices: Estructura Ventajas Desventajas Hash InserciÃ³n y recuperaciÃ³n por igualdad Relaciones de Orden Ãrboles InserciÃ³n y recuperaciÃ³n por igualdad y orden Ocupa mÃ¡s espacio en disco Bitmap Atributos numerados Pocas veces aplicable 41 De agrupamiento 42 Por tanto, para este caso debe verificarse que se encontraron todos los valores recorriendo a partir del obtenido por el Ã­ndice; por este motivo, en general el valor es una lista de punteros 29 ï‚· Ãrboles B y B+: Ãrbol DescripciÃ³n Esquema B Nodo inicial con claves y punteros ordenados B+ Punteros a los datos sÃ³lo en las hojas, mejorando el balanceo ï‚· ComparaciÃ³n entre estructuras: Son comparadas utilizando la cantidad de acceso a disco teniendo en cuenta que en un acceso a disco podrÃ­an recuperarse mÃ¡s de un nodo de la estructura y que estos podrÃ­an buffearse en memoria 30 6.2 Proceso de OptimizaciÃ³n ï‚· Tipos de OptimizaciÃ³n: Tipo Plan DescripciÃ³n HeurÃ­stica LÃ³gico Reduce el Ã¡rbol de consultas en Ã¡lgebra relacional Costos FÃ­sico A cada operaciÃ³n de los Planes LÃ³gicos le asocia una o mÃ¡s implementaciones segÃºn las estructuras disponibles Final EvalÃºa los Planes FÃ­sicos segÃºn los accesos de E/S requeridos ï‚· Proceso de OptimizaciÃ³n: # Etapa DescripciÃ³n Ejemplo 1 Ãlgebra Relacional Se construye la consulta en Ãlgebra Relacional partiendo de SQL como: âˆ ğœğ‘¤â„ğ‘’ğ‘Ÿğ‘’(Ã—ğ‘“ğ‘Ÿğ‘œğ‘š) ğ‘ ğ‘’ğ‘™ğ‘’ğ‘ğ‘¡ Obteniendo un Ã¡rbol canÃ³nico select e.nombre, d.piso from departamentos d, empleados e where e.depto = d.nroD and e.salario > 30000 2 Planes LÃ³gicos A partir del Ã¡rbol canÃ³nico se reduce el Ã¡rbol empleando: - Equivalencias de expresiones - CatÃ¡logo del a DB En cada arista se indica la cantidad de tuplas estimadas que cumplen con las condiciones de la operaciÃ³n de destino CatÃ¡logo de la DB: Planes LÃ³gicos: 3 Planes FÃ­sicos Se consideran las implementaciones de ğœ y â‹ˆ para determinar los costos de cada plan OperaciÃ³n ImplementaciÃ³n ğˆ BÃºsqueda Lineal BÃºsqueda Binaria Ãndice â‹ˆ Loop anidado Loop Ãºnico Sort Merge 4 Plan Final Calculados los costos de cada plan, se selecciona el de menor valor ï‚· Ãndices en el presente modelo teÃ³rico: En el modelo teÃ³rico que aquÃ­ se construye, asume que los Ã­ndices sÃ³lo pueden ser empleados en el primer nivel de las operaciones (segÃºn el Plan LÃ³gico) 31 6.3 OptimizaciÃ³n por HeurÃ­sticas ï‚· Criterios: # Elemento AcciÃ³n 0 En todos los casos y siempre que sea posible, deben aplicarse las Equivalencias de Expresiones a fin de minimizar las operaciones de la consulta 1 ğœ Descomponer en ğœs mÃ¡s simples 2 ğœ Mover lo mÃ¡s abajo posible 3 Mover a la izquierda las ramas con menos tuplas 4 (ğœ,Ã—) Reemplazar por â‹ˆğ‘ğ‘œğ‘›ğ‘‘ğ‘–ğ‘ğ‘–Ã³ğ‘› 5 ğœ‹ Mover lo mÃ¡s abajo posible agregando los ğœ‹s necesarios43 ï‚· Equivalencia de expresiones: CategorÃ­a Equivalencia DescripciÃ³n/Aclaraciones ğˆ DescomposiciÃ³n Conmutatividad ğ… ğœ‹ğ‘ğ‘–(ğœ‹ğ‘1,â€¦ğ‘ğ‘›ğ‘…) = ğœ‹ğ‘ğ‘–ğ‘… EliminaciÃ³n de redundancia ğœ‹ğ‘ğœğ‘ğ‘… = ğœğ‘ğœ‹ğ‘ğ‘… ConmutaciÃ³n con ğœ si Ã©ste contiene atributos de ğœ‹ â‹ˆ ğœğ‘(ğ‘… Ã— ğ‘„) = ğ‘… â‹ˆğ‘ ğ‘„ Equivalencia de (ğœ,Ã—) Asociatividad de â‹ˆğ‘ Conmutatividad de â‹ˆğ‘ Ã— ğœğ‘(ğ‘… Ã— ğ‘„) = (ğœğ‘ğ‘…) Ã— ğ‘„ Si c sÃ³lo contiene atributos de R ğœ‹ğ‘âˆªğ‘(ğ‘… Ã— ğ‘„) = ğœ‹ğ‘ğ‘… Ã— ğœ‹ğ‘ğ‘„ Si a es de R y b es de Q âˆª/âˆ© Reglas de conjuntos ğœğ‘(ğ‘… âˆª ğ‘„) = ğœğ‘ğ‘… âˆª ğœğ‘ğ‘„ AnÃ¡logo para âˆ©, âˆ’ y ğœ‹ en lugar de ğœ ï‚· Ejemplo: 43 En general, no se aplica debido a la pÃ©rdida de Ã­ndices y la necesidad de mantener varios atributos de proyecciÃ³n en los niveles inferiores porque serÃ¡n utilizados en los niveles superiores 32 6.4 OptimizaciÃ³n por Costos ï‚· ParÃ¡metros: NotaciÃ³n Unidad DefiniciÃ³n FÃ³rmula ğ’ğ‘» tuplas â€¦de la tabla T ğ‘¹ğ‘» bytes â€¦de una tupla de T ğ’ƒğ‘» bloques â€¦necesarios para almacenar las tuplas de T âŒˆ ğ‘›ğ‘‡ ğ‘ğ‘“ğ‘Ÿğ‘‡ âŒ‰ ğ’ƒğ’‡ğ‘» tuplas â€¦en un bloque de T âŒŠğ‘ğ‘¦ğ‘¡ğ‘’ğ‘  ğ‘‘ğ‘’ğ‘™ ğ‘ğ‘™ğ‘œğ‘ğ‘¢ğ‘’ ğ‘ğ‘¦ğ‘¡ğ‘’ğ‘  ğ‘‘ğ‘’ ğ‘™ğ‘ ğ‘¡ğ‘¢ğ‘ğ‘™ğ‘âŒ‹ ğ’™ğ‘» niveles â€¦de un Ã­ndice de T logğ‘˜ ğ‘›ğ‘‡ + 144 ğ‘½(ğ‘¨, ğ‘») â€¦valores distintos que tiene un atributo A sobre una tabla T ğ‘›ğ‘‡ 45 ğ’”ğ’(ğˆğ’„ğ‘») tuplas FracciÃ³n de tuplas que cumplen c en T original 1 ğ‘‰(ğ´, ğ‘‡) 46 ğ’‹ğ’”(ğ‘¹ â‹ˆğ’„ ğ‘º) tuplas â€¦que deben seleccionarse respecto del producto de Ã— 1 ğ‘šğ‘–ğ‘›{ğ‘‰(ğ´, ğ‘…), ğ‘‰(ğ´, ğ‘†)} 47 ğ‘»(ğˆğ’„ğ‘¹) tuplas â€¦que cumplen con c en T ğ‘›ğ‘… Ã— ğ‘ ğ‘™(ğœğ‘ğ‘…) ğ‘»(ğ‘¹ â‹ˆğ’„ ğ‘º) tuplas â€¦que cumplen con â‹ˆğ‘ ğ‘›ğ‘… Ã— ğ‘›ğ‘† Ã— ğ‘—ğ‘ (ğ‘… â‹ˆğ‘ ğ‘†) ï‚· Estrategia de implementaciÃ³n de operadores: Pipelined EjecuciÃ³n paralela de operadores GeneraciÃ³n de resultados AplicaciÃ³n ï ï Son comunicados entre operadores sin grabarse a disco48 ğœ‹ ï ï Son comunicados entre operadores grabando resultados intermedios ğœ â‹ˆ ï‚· Estimaciones de costos: Los costos son calculados para cada bloque de disco49 en las acciones de: Lectura Depende de la organizaciÃ³n de los datos Escritura Costo de grabar todo el resultado R: âŒˆ ğ‘›ğ‘… ğ‘ğ‘“ğ‘…âŒ‰ 44 Para un B+ con k punteros por nodo sobre clave 45 Para un atributo clave 46 Si la condiciÃ³n es una igualdad sobre A y se asume distribuciÃ³n uniforme 47 Si es ğ‘… â‹ˆ ğ‘† natural sobre A 48 No hay costo de lectura ya que los datos estÃ¡n en el buffer 49 Que por tanto pueden contener varios registros o Ã­ndices 33 ï‚· ImplementaciÃ³n de operadores: Operador Estrategia RestricciÃ³n DescripciÃ³n Costo de lectura50 ğˆğ’„ğ‘¹ BÃºsqueda Lineal â€¦de los registros que cumplen c Caso promedio: ğ‘ğ‘… 2 Peor caso: ğ‘ğ‘… BÃºsqueda Binaria OrdenaciÃ³n Se divide la cantidad de registro y se lee en el sentido de la ordenaciÃ³n log2 ğ‘ğ‘… + âŒˆ ğ‘  ğ‘ğ‘…âŒ‰ âˆ’ 1 Ãndice Primario OrdenaciÃ³n Se consulta el Ã­ndice ğ‘¥ + 1 Ãndice de Cluster OrdenaciÃ³n Se consulta el Ã­ndice ğ‘¥ + âŒˆ ğ‘  ğ‘ğ‘“ğ‘…âŒ‰ Ãndice Hash c relaciÃ³n de igualdad Lectura sobre el Ã­ndice 1 o 2 Ãndice secundario con B+ Se sigue la estructura B+ Peor caso: ğ‘¥ + ğ‘  ğ‘¹ â‹ˆğ’„ ğ‘º Loop anidado por registros LeÃ­da una tupla de R, se leen todas las tuplas de S ğ‘ğ‘… + ğ‘›ğ‘… Ã— ğ‘ğ‘† Loop anidado por bloques LeÃ­do un bloque de R, se leen todos los bloques de S ğ‘ğ‘… + âŒˆ ğ‘ğ‘… ğ‘€ âˆ’ 2 âŒ‰ Ã— ğ‘ğ‘† 51 Sort-Merge Join OrdenaciÃ³n en R y S Recorrer S y R en paralelo: por cada valor ordenado de R se recorren los valores de S que le correspondan segÃºn c52 (y Ã©stos serÃ¡n un conjunto ordenado de S) Costo de lectura: ğ‘ğ‘… + ğ‘ğ‘† Costo de ordenaciÃ³n: 2 Ã— ğ‘ Ã— (1 + log2 ğ‘) Index Join (Single Loop) Ãndice sobre S Recorrer R accediendo por Ã­ndice a S ğ‘ğ‘… + (ğ‘›ğ‘… Ã— ğ‘) Donde Z: Ãndice Z Secundario ğ‘¥ + ğ‘ ğ‘† Cluster ğ‘¥ + âŒˆ ğ‘ ğ‘† ğ‘ğ‘“ğ‘†âŒ‰ Primario ğ‘¥ + 1 Hash â„ 50 x representa la cantidad de niveles del Ã­ndice. s la cantidad de tuplas resultado de la operaciÃ³n 51 M indica el tamaÃ±o del buffer. Es âˆ’2 porque uno se usa para R y otro para S. El factor âŒˆ ğ‘ğ‘… ğ‘€âˆ’2âŒ‰ indica la cantidad de bloques de S que se pueden leer a la vez 52 Y Ã©stos serÃ¡n un conjunto ordenado de S. Por ejemplo, si c fuera de igualdad, para cada registro de R se recorren los S que le sean iguales, cuando deje de cumplirlo, es a partir de allÃ­ que debe analizarse para el siguiente registro de R 34 ï‚· Ejemplo: Plan LÃ³gico Valores del CatÃ¡logo Planes FÃ­sicos Mejor plan SelecciÃ³n con Ãndice Secundario y Join con Loop Anidado por Bloques, dando como resultado, 26 + 3 = 29 operaciones 35 36 7. Control de Concurrencia y RecuperaciÃ³n 7.1 Transacciones e Historias ï‚· Propiedad ACID: Un proceso cumple con la propiedad ACID si cumple con las siguientes propiedades: Sigla Propiedad DescripciÃ³n A Atomicidad La ejecuciÃ³n es considerada una unidad de trabajo C Consistencia Mantiene la consistencia de la DB I Aislamiento Su ejecuciÃ³n no interfiere con otra D Durabilidad Sus modificaciones son persistentes en la DB ï‚· TransacciÃ³n: Procesos concurrentes que ejecutan sobre datos compartidos y cumplen la propiedad ACID ï‚· Estados de una TransacciÃ³n: ï‚· Operaciones de una TransacciÃ³n53: AcciÃ³n NotaciÃ³n completa NotaciÃ³n compacta Leer ğ‘Ÿğ‘’ğ‘ğ‘‘ğ‘–(ğ‘‹) ğ‘Ÿğ‘–(ğ‘‹) Escribir ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’ğ‘–(ğ‘‹) ğ‘¤ğ‘–(ğ‘‹) Confirmar ğ‘ğ‘œğ‘šğ‘šğ‘–ğ‘¡ğ‘– ğ‘ğ‘– Abortar ğ‘ğ‘ğ‘œğ‘Ÿğ‘¡ğ‘– ğ‘ğ‘– ï‚· Rollback: AcciÃ³n de recuperaciÃ³n de la DB a un estado previo a la ejecuciÃ³n de ğ‘ğ‘– en una TransacciÃ³n ï‚· Grafo de Seriabilidad: Grafo de precedencia de las Transacciones que componen una Historia. Construido como: Paso Componente54 AcciÃ³n 1 ğ‘‡ğ‘– Nodo ğ‘‡ğ‘– 2 ğ‘¤ğ‘– â€¦ ğ‘Ÿğ‘— ğ‘‡ğ‘– â†’ ğ‘‡ğ‘— 3 ğ‘Ÿğ‘– â€¦ ğ‘¤ğ‘— ğ‘‡ğ‘– â†’ ğ‘‡ğ‘— 4 ğ‘¤ğ‘– â€¦ ğ‘¤ğ‘— ğ‘‡ğ‘– â†’ ğ‘‡ğ‘— 53 i representa el nÃºmero de la TransacciÃ³n y X el lugar de la DB sobre el que se opera. La secuencia de estas operaciones, identifica una TransacciÃ³n 54 Los r y w de esta columna tienen el mismo parÃ¡metro 37 ï‚· Historia: OrdenaciÃ³n de las operaciones de un conjunto determinado de transacciones que aparecen de forma lineal respecto de Ã©sta55 ï‚· ClasificaciÃ³n de Historias: Historia DefiniciÃ³n DescripciÃ³n Serializable Su Grafo de Seriabilidad es acÃ­clico56 Recuperable Ninguna transacciÃ³n confirma si no han confirmado aquellas desde las que se leyÃ³ datos previamente modificados Los commits aparecen en el orden de flujo de datos: Se satisfacen las dependencias de confirmaciones57 Evitan Abortos en Cascada Ninguna transacciÃ³n lee valores escritos por otras no confirmadas Que una transacciÃ³n grabe y haga un commit antes de que otra lea Estricta Ninguna transacciÃ³n lee o escribe hasta que todas las que escribieron sobre el mismo Ã­tem fueron confirmadas No hay un w ni un r si no existiÃ³ sobre ese Ã­tem modificado un c ï‚· Relaciones entre las Historias: ï‚· Transaction Manager (TM): MÃ³dulo del DBMS encargado de construir las transacciones y ordenarlas en historias serializables, recuperables y que no tengan abortos en cascada. Puede cambiar un ğ‘ğ‘– por un ğ‘ğ‘– 7.2 Control de Concurrencia ï‚· Lock y Unlock binarios: OperaciÃ³n con comportamiento anÃ¡logo a los semÃ¡foros de SOs cuyo dominio es una porciÃ³n de la DB y su codominio la transacciÃ³n en la que se ejecuta: OperaciÃ³n NotaciÃ³n completa NotaciÃ³n compacta AcciÃ³n de bloqueo/desbloqueo sobre X Lock ğ‘™ğ‘œğ‘ğ‘˜ğ‘–(ğ‘‹) ğ‘™ğ‘–(ğ‘‹) Todas las operaciones Read Lock ğ‘Ÿğ‘’ğ‘ğ‘‘_ğ‘™ğ‘œğ‘ğ‘˜ğ‘–(ğ‘‹) ğ‘Ÿğ‘™ğ‘–(ğ‘‹) Escrituras Write Lock ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’_ğ‘™ğ‘œğ‘ğ‘˜ğ‘–(ğ‘‹) ğ‘¤ğ‘™ğ‘–(ğ‘‹) Todas las operaciones Unlock ğ‘¢ğ‘›ğ‘™ğ‘œğ‘ğ‘˜ğ‘–(ğ‘‹) ğ‘¢ğ‘–(ğ‘‹) Todas las operaciones 55 Esto es, se â€œintercalanâ€ operaciones de todas las transacciones pero nunca se cambia el orden relativo dentro de la transacciÃ³n al a que pertenecen 56 Si posee ciclos, sufre de deadlock 57 PodrÃ­a pensarse como quÃ© pasarÃ­a con transacciones que aÃºn no confirmaron respecto de una que ya lo hizo: si el aborto de aquella impacta sobre estas, entonces, no es recuperable 38 ï‚· Protocolo de Locking 2PL: Reglas de locking que garanticen la seriabilidad: Variante DescripciÃ³n CaracterÃ­sticas Ejemplo BÃ¡sico A lo largo de una Historia, primero estÃ¡n todos los l (fase de expansiÃ³n) y luego y luego todos los u (fase de contracciÃ³n) ï‚­ FÃ¡cil ï‚¯ Deadlock58 ğ‘Ÿğ‘™ğ‘–(ğ‘‹) â€¦ ğ‘¤ğ‘™ğ‘—(ğ‘Œ)âŸ ğ¸ğ‘¥ğ‘ğ‘ğ‘›ğ‘ ğ‘–Ã³ğ‘› â€¦ ğ‘¢ğ‘–(ğ‘‹) â€¦ ğ‘¢ğ‘—(ğ‘Œ)âŸ ğ¶ğ‘œğ‘›ğ‘¡ğ‘Ÿğ‘ğ‘ğ‘ğ‘–Ã³ğ‘› Conservador Declarar primero todos los l ï‚­ No hay Deadlock ï‚¯ Exige declarar todo lo que se utilizarÃ¡ ğ‘Ÿğ‘™ğ‘–(ğ‘‹)ğ‘¤ğ‘™ğ‘—(ğ‘Œ) â€¦ ğ‘¢ğ‘–(ğ‘‹)ğ‘¢ğ‘—(ğ‘Œ) Estricto No se liberan wl hasta confirmar la T ï‚­ Historias Estrictas ï‚¯ Deadlock â€¦ ğ‘¤ğ‘™ğ‘–(ğ‘‹) â€¦ ğ‘ğ‘–ğ‘¢ğ‘–(ğ‘‹) Riguroso No se liberan ni wl ni rl hasta confirmar la T ï‚­ FÃ¡cil (respecto del Estricto) ï‚¯ Deadlock â€¦ ğ‘Ÿğ‘™ğ‘–(ğ‘‹)ğ‘¤ğ‘™ğ‘—(ğ‘Œ) â€¦ ğ‘ğ‘–ğ‘¢ğ‘–(ğ‘‹)ğ‘¢ğ‘—(ğ‘Œ) ï‚· TimeStamp (TS): Para cada Ã­tem X se define un Read_TS(X) y un Write_TS(X) que informa el TS de la transacciÃ³n mÃ¡s joven que leyÃ³ y escribiÃ³ sobre Ã©l respectivamente ï‚· Control de Concurrencia basado en TS: AcciÃ³n que pretende T CondiciÃ³n para su ejecuciÃ³n TS(T) AcciÃ³n w(X) Nadie leyÃ³ o escribiÃ³ posteriormente a T < Read_TS(X) T es reiniciado con un TS actualizado < Write_TS(X) Caso contrario Se cambia Write_TS(X) por TS(X) r(X) Nadie escribiÃ³ posteriormente a T < Write_TS(X) T es reiniciado con un TS actualizado Caso contrario ğ‘…ğ‘’ğ‘ğ‘‘_ğ‘‡ğ‘†(ğ‘‹) = ğ‘šğ‘ğ‘¥{ğ‘‡ğ‘†(ğ‘‡), ğ‘…ğ‘’ğ‘ğ‘‘_ğ‘‡ğ‘†(ğ‘‹)} ï‚· MultiversiÃ³n: Se mantienen varias versiones de cada Ã­tem y se selecciona la adecuada para cada transacciÃ³n: ğ‘‹ = {( ğ‘‹ğ‘–, ğ‘…ğ‘’ğ‘ğ‘‘ğ‘‡ğ‘†(ğ‘‹ğ‘–), ğ‘Šğ‘Ÿğ‘–ğ‘¡ğ‘’ğ‘‡ğ‘†(ğ‘‹ğ‘–) )} ğ‘–=1,â€¦,ğ‘› ï‚· Control de Concurrencia basado en MultiversiÃ³n: AcciÃ³n que pretende T CondiciÃ³n para su ejecuciÃ³n TS(T) AcciÃ³n w(X) Nadie leyÃ³ posteriormente a T ğ‘Šğ‘Ÿğ‘–ğ‘¡ğ‘’_ğ‘‡ğ‘†(ğ‘‹ğ‘–) â‰¤ ğ‘‡ğ‘†(ğ‘‡) < ğ‘…ğ‘’ğ‘ğ‘‘_ğ‘‡ğ‘†(ğ‘‹ğ‘–) T es reiniciado con un TS actualizado Caso contrario Se crea (ğ‘‹ğ‘—, ğ‘‡ğ‘†(ğ‘‡), ğ‘‡ğ‘†(ğ‘‡)) r(X) Ninguna: Se utiliza la Ãºltima escritura mÃ¡s cercana a T < Write_TS(X) T es reiniciado con un TS actualizado Caso contrario ğ‘…ğ‘’ğ‘ğ‘‘_ğ‘‡ğ‘†(ğ‘‹) = ğ‘šğ‘ğ‘¥{ğ‘‡ğ‘†(ğ‘‡), ğ‘…ğ‘’ğ‘ğ‘‘_ğ‘‡ğ‘†(ğ‘‹)} 7.3 Otros aspectos de Concurrencia ï‚· Granularidad: Refiere al detalle con el que se define un Ã­tem X: tupla, registro, tabla, bloque de discoâ€¦ ï‚· Granularidad y performance: Granularidad Impacto Mayor Menor concurrencia Menor Mayor overhead 58 En esta columna, esto significa â€œSusceptible aâ€¦â€ 39 ï‚· Registros Fantasmas: Es un registro que, a la espera de un desbloqueo, no es insertado pese a que es de interÃ©s para la transacciÃ³n bloqueante ï‚· DetecciÃ³n de Deadlocks: Mantener un grafo de espera que detecte la existencia de deadlocks ï‚· SoluciÃ³n a Deadlocks: Timeout Si una transacciÃ³n espera por mucho tiempo, reiniciarla Basados en TS Estrategia DescripciÃ³n Wait-Die La transacciÃ³n mÃ¡s nueva del deadlock debe abortar y recomenzar con el mismo TS Wound-Wait La transacciÃ³n mÃ¡s nueva del deadlock debe esperar por la mÃ¡s vieja ï‚· Starvation: Wait-Die y Wound-Wait evitan el problema que, generalmente, pueden originarse por malos mecanismos de â€œselecciÃ³n de vÃ­ctimaâ€ (puede suceder por su reinicio indefinido) 7.4 RecuperaciÃ³n ï‚· Log: Registro de actividad sobre la DB ï‚· AdministraciÃ³n de logs: Deben respaldarse frecuentemente y almacenarse en lugares distintos a la DB ï‚· Valores posibles de un Ã­tem: Sigla Valor Valor del Ã­tem respecto de la actualizaciÃ³n Log de59 BFIM BeFore IMage Antes Undo AFIM AFter IMage DespuÃ©s Redo ï‚· Ciclo de vida de una instrucciÃ³n de una transacciÃ³n: Paso DescripciÃ³n Esquema 1 Se hacen los cambios en un buffer de memoria ï‚¶ 2 Se registran los cambios en el log ï€´ 3 La transacciÃ³n confirma ï 4 Se baja el log al disco ï€´ï‚¯ï‚³ 5 Se bajan los cambios al disco ï‚¶ï‚¯ï‚³ 59 ClasificaciÃ³n de un log que contiene una operaciÃ³n y el registro BFIM/AFIM 40 ï‚· TÃ©cnicas de recuperaciÃ³n: ActualizaciÃ³n Operativa Ante un abort Diferida Cada transacciÃ³n trabaja en una sandbox que es enviada a disco luego del commit No debe realizarse acciÃ³n alguna Inmediata La base es actualizada antes del commit Se deben deshacer las operaciones de la transacciÃ³n valiÃ©ndose del log Shadow Paging60 Cada transacciÃ³n mantiene en memoria un conjunto de punteros hacia los valores originales y los va cambiando a nuevas pÃ¡ginas de memoria a medida que surjan modificaciones Recupera el conjunto de punteros original ï‚· Write-Ahead Loggin (WAL): Protocolo que garantiza que el log con el BFIM estÃ¡ en el disco antes de grabar la operaciÃ³n en la DB ï‚· Checkpoint: Registro del log que indica que todos los buffers modificados de la DB estÃ¡n en disco: Paso DescripciÃ³n Esquema 1 Suspender transacciones en curso ï€» 2 Bajar buffers modificados ï‚¯ï¾ 3 Registrar checkpoint ïï€´ 4 Bajar log ï‚¯ï€´ 5 Reanudar transacciones ï€´ ï‚· Rollback: Se debe realizar cuando una transacciÃ³n aborta. Si otras transacciones se basaron en ella para continuar, Ã©stas tambiÃ©n deben ser abortadas, provocando un aborto en cascada 60 Ãštil para DB de pequeÃ±o porte debido al overhead del sistema 41 ï‚· Algoritmos de recuperaciÃ³n61: Algoritmo Acciones de T confirmada Acciones de T no confirmada Basado en ActualizaciÃ³n Diferida Se reconstruye el resultado utilizando el log Se relanza al finalizar la recuperaciÃ³n Basada en RecuperaciÃ³n Inmediata Se reconstruye el resultado utilizando el log Se revierten los cambios empleando los valores anteriores en el log. Se relanza la transacciÃ³n Shadow Paging Se graban los punteros modificados Se graban los punteros originales 61 Todos ellos asumen la generaciÃ³n de historias estrictas y serializables","libVersion":"0.3.1","langs":""}