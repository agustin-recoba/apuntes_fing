El algoritmo por vector de distancias (DV) es iterativo, as√≠ncrono y distribuido. 
- Es **distribuido** en el sentido de que cada nodo recibe informaci√≥n de uno o m√°s de sus vecinos directamente conectados, realiza un c√°lculo y luego distribuye los resultados de su c√°lculo de vuelta a sus vecinos. 
- Es **iterativo** porque este proceso contin√∫a hasta que no hay disponible m√°s informaci√≥n para ser intercambiada entre los vecinos.
- El algoritmo es **as√≠ncrono**, en el sentido de que no requiere que todos los nodos operen sincronizados entre s√≠.

```ad-important
title: Ecuaci√≥n de Bellman-Ford
<br />

$$d_x (y) = min_{v} \{c(x, v) + d_v(y)\}$$

<br />

Donde $d_x (y)$ representa la distancia m√≠nima de $x$ a $y$, $c(x, v)$ indica el costo f√≠sico del link que conecta el nodo $x$ con el $v$, y $d_v(y)$ es la distancia m√≠nima en la cual el nodo $v$ puede llegar al nodo $y$. En definitiva, la distancia se calcula como la distancia hacia el nodo ùë£ que presenta la distancia m√≠nima al nodo buscado, y el costo de llegar a ese nodo $v$.
```

En el algoritmo, de vez en cuando, cada nodo env√≠a una copia de su vector de distancias a cada uno de sus vecinos. Cuando un nodo x recibe un nuevo vector de distancias procedente de cualquiera de sus vecinos v, guarda dicho vector de v y luego utiliza la ecuaci√≥n de Bellman-Ford para actualizar su propio vector de distancias.
Si el vector de distancias del nodo x ha cambiado como resultado de este paso de actualizaci√≥n, entonces el nodo x enviar√° su vector de distancias actualizado a cada uno de sus vecinos, lo que puede a su vez actualizar sus propios vectores distancia.

```python
1  Inicializaci√≥n: 
2      for todos los destinos y vecinos de x: 
3          Dx(y) = c(x,y) 
4      for cada vecino w de x 
5          Dw(y) = ‚àû para todos los destinos y vecinos de x
6      for cada vecino w de x 
7          enviar vector de distancias Dx = [Dx(y): y vecino de x] a w 
8 
9  while True: 
10     wait (hasta ver una variaci√≥n en el coste de enlace de un vecino w 
11             o hasta recibir un vector de distancias de alg√∫n vecino w) 
12 
13     for cada y conocido de x: // pueden haber tanto conocidos vecinos 
14                              // como conocidos no vecinos 
15         Dx(y) = minv vecino de x{c(x,v) + Dv(y)} 
16  
17     if Dx(y) se modifica para cualquier y conocido de x 
18         enviar vector de distancia Dx = [Dx(y): y conocido de x] a 
19         todos los vecinos 
```

El proceso de recibir vectores distancia actualizados de los vecinos, recalcular las entradas de la tabla de enrutamiento e informar a los vecinos de los costes modificados de la ruta de coste m√≠nimo hacia un destino contin√∫a hasta que ya no se env√≠an mensajes de actualizaci√≥n. **El algoritmo se encuentra en estado de reposo.**

# Conteo al infinito

Si bien el algoritmo funciona bien con costos de link fijos, cabe destacar lo que sucede cuando el costo de un link cambia en la red. Para ello, se debe considerar dos casos diferentes: cuando un link disminuye, y cuando uno de ellos aumenta. 

Para ejemplificar lo que sucede, se presentan las siguientes redes:
![[Pasted image 20221118103043.png]]

En esta oportunidad, se realiza un cambio de costo disminuyendo el link que conecta x e y.

En el tiempo $t_0$, $y$ detecta el cambio de link y env√≠a dicho cambio a sus vecinos. En $t_1$, $z$ recibe el vector de $y$ y actualiza su vector: $D_z(x)= min\{1 + 1, 50 + 0\} = 2$. En $t_2$, $y$ recibe el vector de $z$ y actualiza su vector, pero este permanece incambiado, por lo que no env√≠a m√°s mensajes a sus vecinos. En definitiva, se requieren solamente dos iteraciones para que las tablas converjan.

Esta vez, se aumenta el link que conecta x e y a 60. 
En tiempo $t_0$, $y$ detecta el cambio de link, y computa un nuevo m√≠nimo: $D_y(x)= min\{60+0, 1+5\} = 6$. Claramente, el costo computado es err√≥neo (ya que el costo del camino m√≠nimo entre x e y es de 51), pero con la informaci√≥n manejada por el nodo no se puede determinar el costo correcto. Se env√≠a a sus vecinos el vector costos con el nuevo costo determinado. En $t_2$, z recibe el vector de $y$, y computa lo siguiente: $D_y(x)= min\{50+0, 6+1\} = 7$ siendo este costo tambi√©n incorrecto. Luego env√≠a su vector de distancia actualizado. 
Este ciclo de c√≥mputos incorrectos continuar√° aumentando el valor en una unidad en cada nodo hasta que $z$ determine el costo como $D_z(x)= min\{50+0, 50+1\}$, qued√°ndose as√≠ con el primer t√©rmino, lo que implica que rutea a $x$ directamente por el link que los conecta. Este proceso durar√° **44 iteraciones**, que es lo que demora el costo m√≠nimo en llegar de 6 a 50.

## Reversa envenenada
Para solucionar este problema, se utiliza la t√©cnica conocida como reversa envenenada. Sup√≥ngase que un nodo x debe enviar su vector de distancia a sus vecinos. Sup√≥ngase tambi√©n que el pr√≥ximo nodo al que se debe enviar el vector es al nodo y. Antes de realizar el env√≠o, el nodo x modificar√° las entradas del vector de distancia correspondientes a los nodos que alcanza mediante y por el valor ‚Äúinfinito‚Äù. 

En otros t√©rminos, si $next\_hop_x(z) = y ‚üπ D_x(z)=\infty$. De esta manera, el nodo y creer√° que no existe un camino de √©l hacia $z$ que pase por $x$ y no intentar√° enviar el paquete destinado a $z$ por esa ruta.

```ad-warning
title: Cuidado
No funciona siempre para topolog√≠as complejas.
```
